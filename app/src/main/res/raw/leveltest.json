[
  {
    "CAT_ID": 1,
    "CAT_NAME": "C Programming",
    "LEVELS": [
      {
        "LEVEL_ID": 1,
        "LEVEL_NAME": "Practical",
        "LOCK_STATUS": 0,
        "QUESTIONS": [
          {
            "Q_ID": 1,
            "Q_TEXT": "HCF and LCM",
            "Q_PRGM": "#include \\nint main()\\n{\\n\\tint a, b, x, y, t, gcd, lcm;\\n\\tprintf(\"Enter two integers\");\\n\\tscanf(\"%d%d\", &x, &y);\\n\\n\\ta = x;\\n\\t b = y;\\n\\n\\twhile (b != 0) \\n{\\n\\tt = b;\\n\\tb = a % b;\\n\\ta = t;\\n}\\ngcd = a;\\nlcm = (x*y)/gcd;\\nprintf(\"Greatest common divisor of %d and %d = %d\", x, y, gcd);\\nprintf(\"Least common multiple of %d and %d = %d\", x, y,   lcm);\\nreturn 0;\\n}",
            "OPT_A": "Enter two integers\\n9\\n24\\nGreatest common divisor of 9 and 24 = 3\\nLeast common multiple of 9 and 24 = 72",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 2,
            "Q_TEXT": "Factorial",
            "Q_PRGM": "#include <stdio.h>\\nint main()\\n{\\n\\tint c, n, fact = 1;\\n\\tprintf(\"Enter a number to calculate it's factorial\");\\n\\tscanf(\"%d\", &n);\\n\\tfor (c = 1; c <= n; c++)\\n\\t{\\n\\t\\tfact = fact * c;\\n\\t}\\n\\tprintf(\"Factorial of %d = %d\", n, fact);\\n\\treturn 0;\\n}",
            "OPT_A": "Enter a number to calculate it's factorial\\n5\\nFactorial of 5 = 120",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 3,
            "Q_TEXT": "To check odd or even",
            "Q_PRGM": "#include <stdio.h>\\nint main()\\n{\\n\\tint n;\\n\\tprintf(\"Enter an integer\");\\n\\t\\tscanf(\"%d\",&n);\\n\\t\\tif (n%2 == 0)\\n\\t\\tprintf(\"Even\");\\n\\t\\telse\\n\\t\\tprintf(\"Odd\");\\n\\t\\treturn 0;\\n}",
            "OPT_A": "Enter an integer\\n5\\nOdd",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 4,
            "Q_TEXT": "To perform addition,subtraction,multiplication and division",
            "Q_PRGM": "#include <stdio.h>\\nint main()\\n{\\n\\tint first, second, add, subtract, multiply;\\n\\tfloat divide;\\n\\tprintf(\"Enter two integers\");\\n\\tscanf(\"%d%d\", &first, &second);\\n\\tadd = first + second;\\n\\tsubtract = first - second;\\n\\t\\n\\tmultiply = first * second;\\n\\tdivide = first / (float)second;\\n\\tprintf(\"Sum = %d\n\",add);\\n\\tprintf(\"Difference = %d\n\",subtract);\\n\\tprintf(\"Multiplication = %d\n\",multiply);\\n\\tprintf(\"Division = %.2f\n\",divide);\\n\\treturn 0;\\n}",
            "OPT_A": "Enter two integers\\n7 3\\nSum=10\\nDifference=4\\nMultiplication=21\\nDivision=2.33",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 5,
            "Q_TEXT": "To check whether input alphabet is a vowel or not",
            "Q_PRGM": "#include<stdio.h>\\nint main()\\n{\\n\\\tchar ch;\\n\\tprintf(\"Enter a character\n\");\\n\\tscanf(\"%c\", &ch);\\n\\tif (ch == 'a' || ch == 'A' || ch == 'e' || ch == 'E' || ch ==    'i' || ch == 'I' || ch =='o' || ch=='O' || ch == 'u' || ch ==  'U')\\n\\t\\tprintf(\"%c is a vowel.\n\", ch);\\n\\telse\\n\\tprintf(\"%c is not a vowel.\n\", ch);\\n\\treturn 0;\\n}",
            "OPT_A": "Enter a character\\nR\\nR is not a vowel.\\n",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 6,
            "Q_TEXT": "To check leap year",
            "Q_PRGM": "#include <stdio.h>\\nint main()\\n{\\n\\tint year;\\n\\tprintf(\"Enter a year to check if it is a leap year\n\");\\n\\tscanf(\"%d\", &year);\\nif ( year%400 == 0)\\n\\tprintf(\"%d is a leap year.\", year);\\nelse if ( year%100 == 0)\\n\\tprintf(\"%d is not a leap year.\", year);\\n\\telse if ( year%4 == 0 )\\n\\tprintf(\"%d is a leap year.\", year);\\nelse\\n\\tprintf(\"%d is not a leap year.\", year);\\nreturn 0;\\n}",
            "OPT_A": "Enter a year to check if it is a leap year\\n2016\\n2016 is a leap year.",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 7,
            "Q_TEXT": "Add digits of number",
            "Q_PRGM": "#include <stdio.h>\\nint main()\\n{\\n\\tint n, t, sum = 0, remainder;\\n\\tprintf(\"Enter an integer\n\");\\n\\tscanf(\"%d\", &n);\\n\\tt = n;while (t != 0)\\n\\t{\\n\\t\\tremainder = t % 10;\\n\\t\\tsum=sum + remainder;\\n\\t\\tt = t / 10;\\n\\t}\\n\\tprintf(\"Sum of digits of %d = %d\n\", n, sum);\\nreturn 0;\\n}",
            "OPT_A": "Enter an integer\\n1234\\nSum of digits of 1234=10",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 8,
            "Q_TEXT": "Decimal to binary conversion",
            "Q_PRGM": "#include <stdio.h>\\nint main()\\n{\\n\\tint n, c, k;\\n\\tprintf(\"Enter an integer in decimal number system\n\");\\n\\tscanf(\"%d\", &n);  printf(\"%d in binary number system is:\n\",n);\\nfor (c = 31; c >= 0; c--)\\n{\\n\\tk = n >> c;\\n\\tif (k & 1)\\n\\t\\tprintf(\"1\");\\n\\telse\\n\\t\\tprintf(\"0\");\\n\\t}\\n\\tprintf(\"\n\");\\n\\treturn 0;\\n}",
            "OPT_A": "Enter an integer in decimal number system\\n100\\n100 in binary number system is 1100100.\\n",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 9,
            "Q_TEXT": "To find nCr and nPr",
            "Q_PRGM": "#include <stdio.h>\\nlong factorial(int);\\nlong find_ncr(int, int);\\nlong find_npr(int, int);\\nint main()\\n{\\n\\tint n, r;\\n\\tlong ncr, npr;\\n\\tprintf(\"Enter the value of n and r\n\");\\n\\tscanf(\"%d%d\",&n,&r);\\n\\tncr = find_ncr(n, r);\\n\\tnpr = find_npr(n, r);\\n\\tprintf(\"%dC%d = %ld\n\", n, r, ncr);\\n\\tprintf(\"%dP%d = %ld\n\", n, r, npr);\\n\\treturn 0;\\n}\\nlong find_ncr(int n, int r)\\n{\\n\\tlong result;\\n\\tresult = factorial(n)/(factorial(r)*factorial(n-r));\\n\\treturn result;\\n}\\n\\tlong find_npr(int n, int r)\\n{\\n\\tlong result;\\n\\tresult = factorial(n)/factorial(n-r);\\n\\treturn result;\\n}\\n\\tlong factorial(int n)\\n\\t{\\n\\t\\tint c;\\n\\t\\tlong result = 1;\\n\\t\\tfor (c = 1; c <= n; c++)\\n\\t\\t\\tresult = result*c;\\n\\treturn result;\\n}",
            "OPT_A": "Enter the value of n and r\\n5\\n2\\n5C2=10\\n5P2=20",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 10,
            "Q_TEXT": "To swap two numbers",
            "Q_PRGM": "#include <stdio.h>\\nint main()\\n{\\n\\tint x, y, temp;\\n\\tprintf(\"Enter the value of x and y\n\");\\n\\tscanf(\"%d%d\", &x, &y);\\n\\tprintf(\"Before Swapping\nx = %d\ny = %d\n\",x,y);\\n\\ttemp=x;\\n\\tx=y;\\n\\ty=temp;\\n\\tprintf(\"After Swapping\nx = %d\ny = %d\n\",x,y);\\n\\treturn 0;\\n}",
            "OPT_A": "Enter the value of x and y\\n5\\n10\\nBefore Swapping\\nx=5\\ny=10\\nAfter Swapping\\nx=10\\ny=5",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 11,
            "Q_TEXT": "To reverse a number",
            "Q_PRGM": "#include <stdio.h>\\nint main()\\n{\\n\\tint n, reverse = 0;\\n\\tprintf(\"Enter a number to reverse\n\");\\n\\tscanf(\"%d\", &n);\\n\\twhile (n != 0)\\n\\t{\\n\\t\\treverse = reverse * 10;\\n\\t\\treverse = reverse + n%10;\\n\\t\\tn = n/10;\\n\\t}\\n\\tprintf(\"Reverse of entered number is = %d\n\", reverse);\\n\\treturn 0;\\n}",
            "OPT_A": "Enter a number to reverse\\n1234\\nReverse of entered number is = 4321",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 12,
            "Q_TEXT": "Palindrome Numbers",
            "Q_PRGM": "#include <stdio.h>\\nint main()\\n{\\n\\tint n, reverse = 0, temp;\\n\\tprintf(\"Enter a number to check if it is a palindrome or not\n\");\\n\\tscanf(\"%d\",&n);\\n\\ttemp = n;\\n\\twhile( temp != 0 )\\n\\t{\\n\\t\\treverse = reverse * 10;\\n\\t\\treverse = reverse + temp%10;\\n\\t\\ttemp = temp/10;\\n\\t}i\\n\\tf ( n == reverse )\\n\\tprintf(\"%d is a palindrome number.\n\", n);\\n\\telse\\n\\t\\tprintf(\"%d is not a palindrome number.\n\", n);\\n\\treturn 0;\\n\\t}",
            "OPT_A": "Enter a number to check if it is a palindrome or not\\n12321\\n12321 is a palindrome number.\\n",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 13,
            "Q_TEXT": "Prime number",
            "Q_PRGM": "#include<stdio.h>\\nint main()\\n{\\n\\tint n, i = 3, count, c;\\n\\tprintf(\"Enter the number of prime numbers required\n\");\\n\\tscanf(\"%d\",&n);\\n\\tif ( n >= 1 )\\n\\t{\\n\\t\\tprintf(\"First %d prime numbers are :\n\",n);\\n\\tprintf(\"2\n\");\\n\\t}\\n\\tfor ( count = 2 ; count <= n ;  )\\n\\t{\\n\\t\\tfor ( c = 2 ; c <= i - 1 ; c++ )\\n\\t\\t{\\n\\t\\t\\tif( i%c == 0 )\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\tif ( c == i )\\n\\t\\t\\t{\\n\\t\\t\\t\\tprintf(\"%d\n\",i);\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\ti++;\\n\\t\\t}\\n\\treturn 0;\\n}",
            "OPT_A": "Enter the number of prime numbers required\\n10\\nFirst 10 prime numbers are:-\\n2\\n3\\n5\\n7\\n11\\n13\\n17\\n19\\n23\\n29\\n",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 14,
            "Q_TEXT": "Armstrong number",
            "Q_PRGM": "#include <stdio.h>\\nint power(int, int);\\nint main()\\n{\\n\\tint n, sum = 0, temp, remainder, digits = 0;\\n\\tprintf(\"Input an integer\n\");\\n\\tscanf(\"%d\", &n);\\n\\ttemp = n;\\n\\twhile (temp != 0)\\n\\t{\\n\\t\\tdigits++;\\n\\t\\ttemp = temp/10;\\n\\t}\\n\\ttemp = n;\\n\\twhile(temp != 0)\\n\\t\\t{\\n\\t\\t\\tremainder = temp%10;\\n\\t\\t\\tsum = sum + power(remainder, digits);\\n\\t\\t\\ttemp = temp/10;\\n\\t\\t}\\n\\tif (n == sum)\\n\\t\\tprintf(\"%d is an Armstrong number.\n\", n);\\n\\telse\\n\\t\\tprintf(\"%d is not an Armstrong number.\n\", n);\\n\\treturn 0;\\n}",
            "OPT_A": "Input an integer\\n9926315\\n9926315 is an armstrong",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 15,
            "Q_TEXT": "Fibonacci series",
            "Q_PRGM": "#include<stdio.h>\\nint main()\\n{\\n\\tint n, first = 0, second = 1, next, c;\\n\\tprintf(\"Enter the number of terms\n\");\\n\\tscanf(\"%d\",&n);\\n\\tprintf(\"First %d terms of Fibonacci series are :-\n\",n);\\n\\tfor ( c = 0 ; c < n ; c++ )\\n\\t{\\n\\t\\tif ( c <= 1 )\\n\\t\\t\\tnext = c;\\n\\t\\telse\\n\\t\\t{\\n\\t\\tnext = first + second;\\n\\t\\tfirst = second;\\n\\t\\tsecond = next;\\n\\t}\\n\\tprintf(\"%d\n\",next);\\n\\t}\\n\\treturn 0;\\n}",
            "OPT_A": "Enter the number of terms\\n5\\nFirst 5 terms of Fibonacci series are\\n0\\n1\\n1\\n2\\n3\\n",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 16,
            "Q_TEXT": "add two numbers using pointers",
            "Q_PRGM": "#include <stdio.h>\\nint main()\\n{\\n\\tint first, second, *p, *q, sum;\\n\\tprintf(\"Enter two integers to add\n\");\\n\\tscanf(\"%d%d\", &first, &second);\\n\\tp = &first;\\n\\tq = &second;\\n\\tsum = *p + *q;\\n\\tprintf(\"Sum of entered numbers = %d\n\",sum);\\n\\treturn 0;\\n}",
            "OPT_A": "Enter two integers to add\\n4\\n5\\nSum of entered numbers =9",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 17,
            "Q_TEXT": "To find maximum element in array",
            "Q_PRGM": "#include <stdio.h>\\nint main()\\n{\\n\\tint array[100], maximum, size, c, location = 1;\\n\\tprintf(\"Enter the number of elements in array\");\\n\\tscanf(\"%d\", &size);\\n\\tprintf(\"Enter %d integers\n\",size);\\n\\tfor (c = 0; c < size; c++)\\n\\t\\tscanf(\"%d\", &array[c]);\\n\\t\\tmaximum = array[0];\\n\\tfor (c = 1; c < size; c++)\\n\\t{\\n\\t\\tif (array[c] > maximum)\\n\\t\\t{\\n\\t\\t\\tmaximum  = array[c];\\n\\t\\t\\tlocation = c+1;\\n\\t\\t}\\n\\t}\\n\\tprintf(\"Maximum element is present at location %d and it's value is %d.\n\", location, maximum);\\n\\treturn 0;\\n}",
            "OPT_A": "Enter the number of elements in array\\n5\\nEnter 5 integers\\n5\\n7\\n2\\n9\\n1\\nMaximum element is present at location 4 and it's value is 9.\\n",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 18,
            "Q_TEXT": "To find minimum element in array",
            "Q_PRGM": "#include<stdio.h>\\nint main()\\n{\\n\\tint array[100], minimum, size, c, location = 1;\\n\\tprintf(\"Enter the number of elements in array\");\\n\\tscanf(\"%d\",&size);\\n\\tprintf(\"Enter %d integers\", size);\\n\\tfor ( c = 0 ; c < size ; c++ )\\n\\t\\tscanf(\"%d\",&array[c]);\\n\\tminimum = array[0];\\n\\tfor ( c = 1 ; c < size;c++)\\n\\t{\\n\\t\\tif(array[c]<minimum)\\n\\t\\t{\\n\\t\\t\\tminimum = array[c];\\n\\t\\t\\tlocation = c+1;\\n\\t\\t}\\n\\t}\\n\\tprintf(\"Minimum element is present at location %d and it's value is %d.\n\", location, minimum);\\n\\treturn 0;\\n}",
            "OPT_A": "Enter the number of elements in array\\n5\\nEnter 5 integers\\n5\\n7\\n2\\n9\\n1\\nMinimum element is present at location 5 and it's value is 1.",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 19,
            "Q_TEXT": "Binary Search",
            "Q_PRGM": "#include <stdio.h>\\nint main()\\n{\\n\\tint c, first, last, middle, n, search, array[100];\\n\\tprintf(\"Enter number of elements\");\\n\\tscanf(\"%d\",&n);\\n\\tprintf(\"Enter %d integers\", n);\\n\\tfor (c = 0; c < n; c++)\\n\\t\\tscanf(\"%d\",&array[c]);\\n\\tprintf(\"Enter value to find\n\");\\n\\tscanf(\"%d\",&search);\\n\\tfirst = 0;\\n\\tlast = n - 1;\\n\\tmiddle = (first+last)/2;\\n\\twhile (first <= last)\\n\\t{\\n\\t\\tif (array[middle] < search)\\n\\t\\t\\tfirst = middle + 1;\\n\\t\\telse if (array[middle] == search)\\n\\t\\t{\\n\\t\\t\\tprintf(\"%d found at location %d.\n\", search, middle+1);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tlast = middle - 1;\\n\\tmiddle = (first + last)/2;\\n\\t}\\n\\tif (first > last)\\n\\t\\tprintf(\"Not found! %d is not present in the list.\",search);\\n\\treturn 0;\\n}",
            "OPT_A": "Enter the number of elements\\n5\\nEnter 5 integers\\n1\\n5\\n7\\n9\\n10\\nEnter value to find\\n9\\n9 found at location 4.",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 20,
            "Q_TEXT": "Linear Seach",
            "Q_PRGM": "#include <stdio.h>\\nint main()\\n{\\n\\tint array[100], search, c, n;\\n\\tprintf(\"Enter the number of elements in array\");\\n\\tscanf(\"%d\",&n);\\n\\tprintf(\"Enter %d integer(s)\", n);\\n\\tfor (c = 0; c < n; c++)\\n\\t\\tscanf(\"%d\", &array[c]);\\n\\tprintf(\"Enter the number to search\");\\n\\tscanf(\"%d\", &search);\\n\\tfor (c = 0; c < n; c++)\\n\\t{\\n\\t\\tif (array[c] == search)\\n\\t\\t{\\n\\t\\t\\tprintf(\"%d is present at location %d.\n\", search, c+1);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\nif (c == n)\\n\\t\\tprintf(\"%d is not present in array.\", search);\\n\\t return 0;\\n}",
            "OPT_A": "Enter the number of elements in array\\n5\\nEnter 5 numbers\\n2\\n4\\n1\\n6\\n5\\nEnter the number to search\\n6\\n6 is present at location 4.",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 21,
            "Q_TEXT": "Reverse of array",
            "Q_PRGM": "#include <stdio.h>\\nint main()\\n{\\n\\tint n, c, d, a[100], b[100];\\n\\tprintf(\"Enter the number of elements in array\");\\n\\tscanf(\"%d\", &n);\\n\\tprintf(\"Enter the array elements\");\\n\\tfor (c = 0; c < n ; c++)\\n\\t\\tscanf(\"%d\", &a[c]);\\n\\tfor (c = n - 1, d = 0; c >= 0; c--, d++)\\n\\t\\tb[d] = a[c];\\n\\tfor (c = 0; c < n; c++)\\n\\t\\ta[c] = b[c];\\n\\tprintf(\"Reverse array is\");\\n\\tfor (c = 0; c < n; c++)\\n\\tprintf(\"%d\", a[c]);\\n\\treturn 0;\\n}",
            "OPT_A": "Enter the number of elements in array\\n5\\nEnter the array elements\\n4\\n54\\n10\\n23\\n150\\nReverse of array is \\n150\\n23\\n10\\n54\\n4\\n",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 22,
            "Q_TEXT": "Merge Two arrays",
            "Q_PRGM": "#include <stdio.h>\\nvoid merge(int [], int, int [], int, int []);\\nint main()\\n {\\n\\tint a[100], b[100], m, n, c, sorted[200];\\n\\tprintf(\"Input number of elements in first array\");\\n\\tscanf(\"%d\", &m);\\n\\tprintf(\"Input %d integers\", m);\\n\\tfor (c = 0; c < m; c++)\\n\\t{\\n\\t\\tscanf(\"%d\", &a[c]);\\n\\t}\\n\\tprintf(\"Input number of elements in second array\");\\n\\tscanf(\"%d\", &n);\\n\\tprintf(\"Input %d integers\", n);\\n\\tfor (c = 0; c < n; c++)\\n\\t{\\n\\t\\tscanf(\"%d\", &b[c]);\\n\\t}\\n\\tmerge(a, m, b, n, sorted);\\n\\tprintf(\"Sorted array:\");\\n\\tfor (c = 0; c < m + n; c++)\\n\\t{\\n\\t\\tprintf(\"%d\", sorted[c]);\\n\\t}\\n\\treturn 0;\\n}\\nvoid merge(int a[], int m, int b[], int n, int sorted[])\\n{\\n\\tint i, j, k;\\n\\tj = k = 0;\\n\\tfor (i = 0; i < m + n;)\\n\\t{\\n\\t\\tif (j < m && k < n)\\n\\t\\t{\\n\\t\\t\\tif (a[j] < b[k])\\n\\t\\t\\t{\\n\\t\\t\\t\\tsorted[i] = a[j];\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsorted[i] = b[k];\\n\\t\\t\\t\\tk++;\\n\\t\\t\\t}\\n\\t\\ti++;\\n\\t\\t}\\n\\t\\telse if (j == m)\\n\\t\\t{\\n\\t\\t\\tfor (; i < m + n;)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsorted[i] = b[k];\\n\\t\\t\\t\\t\\tk++;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor(; i < m + n;)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsorted[i] = a[j];\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t",
            "OPT_A": "Input number of elements in first array\\n3\\nInput 3 integers\\n2\\n4\\n6\\nInput number of elements in second array\\n3\\Input 3 integers\\n-1\\n2\\n3\\nSorted array:\\n-1\\n2\\n2\\n3\\n4\\n6",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 23,
            "Q_TEXT": "Pattern 1",
            "Q_PRGM": "#include<stdio.h>\\nmain()\\n{\\n\\tint row, c, n, temp;\\n\\tprintf(\"Enter the number of rows in pyramid of stars you wish to see\");\\n\\tscanf(\"%d\",&n);\\n\\ttemp = n;\\n\\tfor ( row = 1 ; row <= n ; row++ )\\n\\t{\\n\\t\\tfor ( c = 1 ; c < temp ; c++ )\\n\\t\\t\\t printf(\" \");\\n\\t\\ttemp--;\\n\\t\\tfor ( c = 1 ; c <= 2*row - 1 ; c++ )\\n\\t\\t\\tprintf(\"*\");\\n\\t\\tprintf(\"\n\");\\n\\t}\\n\\treturn 0;\\n}",
            "OPT_A": "\\t\\t\\t\\t*\\n\\t\\t\\t***\\n\\t\\t*****\\n\\t*******\\n*********",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 24,
            "Q_TEXT": "To print patter",
            "Q_PRGM": "#include<stdio.h>\\nmain()\\n{\\n\\tint n, c, k;\\n\\tprintf(\"Enter number of rows\");\\n\\tscanf(\"%d\",&n);\\n\\tfor ( c = 1 ; c <= n ; c++ )\\n\\t{\\n\\t\\tfor( k = 1 ; k <= c ; k++ )\\n\\t\\t\\tprintf(\"*\");\\n\\t\\tprintf(\"\n\");\\n\\t}\\n}",
            "OPT_A": "*\\n**\\n***\\n****\\n*****",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 25,
            "Q_TEXT": "Pattern 2",
            "Q_PRGM": "#include<stdio.h>\\nmain()\\n{\\n\\tint number = 1, n, c, k;\\n\\tprintf(\"Enter number of rows\n\")\\n\\t;scanf(\"%d\",&n);\\n\\tfor( c = 1 ; c <= n ; c++ )\\n\\t{\\n\\t\\tfor( k = 1 ; k <= c ; k++ )\\n\\t\\t{\\n\\t\\t\\tprintf(\"%d\",number);\\n\\t\\t\\tnumber++;\\n\\t\\t}\\n\\t\\tnumber = 1;\\n\\t\\tprintf(\"\n\");\\n\\t}\\n\\t getch();\\t}",
            "OPT_A": "1\\n1 2\\n1 2 3\\n1 2 3 4\\n",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 26,
            "Q_TEXT": "Pattern 3",
            "Q_PRGM": "#include<stdio.h>\\nmain()\\n{\\n\\tint n, c, k, space;\\n\\tprintf(\"Enter number of rows\n\");\\n\\tscanf(\"%d\",&n);\\n\\tspace = n;\\n\\tfor ( k = 1 ; k <= n ; k++ )\\n\\t\\t{\\n\\t\\tfor ( c = 1 ; c < space ; c++ )\\n\\t\\t\\tprintf(\" \");\\n\\t\\tspace--;\\n\\t\\t for( c = 1 ; c <= k ; c++ )\\n\\t\\t\\tprintf(\"*\");\\n\\t\\tprintf(\"\n\");\\n\\t\\t}\\n\\treturn 0;\\n}",
            "OPT_A": "\t\\t\\t\\t*\\n\\t\\t\\t**\\n\\t\\t***\\n\\t****\\n*****",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 27,
            "Q_TEXT": "Pattern 4",
            "Q_PRGM": "#include<stdio.h>\\nmain()\\n{\\n\\tint n, c, d, num = 1, space;\\n\\tscanf(\"%d\",&n);\\n\\tspace = n - 1;\\n\\tfor ( d = 1 ; d <= n ; d++ )\\n\\t{\\n\\t\\tnum = d;\\n\\t\\tfor ( c = 1 ; c <= space ; c++ )\\n\\t\\t\\tprintf(\" \");\\n\\t\\tspace--;\\n\\t\\tfor ( c = 1 ; c <= d ; c++ )\\n\\t\\t{\\n\\t\\t\\tprintf(\"%d\",num);\\n\\t\\t\\tnum++;\\n\\t\\t}\\n\\t\\tnum--;\\n\\t\\tnum--;\\n\\t\\tfor ( c = 1 ; c < d ; c++)\\n\\t\\t{\\n\\t\\t\\tprintf(\"%d\", num);\\n\\t\\t\\tnum--;\\n\\t\\t}\\n\\t\\tprintf(\"\n\");\\n\\t\\t}\\n\\t\\treturn 0;\\n",
            "OPT_A": "\\t\\t\\t\\t1\\n\\t\\t\\t232\\n\\t\\t34543\\n\\t4567654\\n67898765",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 28,
            "Q_TEXT": "To print patter",
            "Q_PRGM": "#include<stdio.h>\\nmain()\\n{\\n\\tint n, c, k, x = 1;\\n\\tscanf(\"%d\", &n);\\n\\tfor ( c = 1 ; c <= n ; c++ )\\n\\t{\\n\\t\\tfor ( k = 1 ; k <= c ; k++ )\\n\\t\\t\\t{\\n\\t\\t\\t\\tprintf(\"%d\", x);\\n\\t\\t\\t\\tx++;\\n\\t\\t\\t}\\n\\t\\tx--;\\n\\t\\tfor ( k = 1 ; k <= c - 1 ; k++ )\\n\\t\\t{\\n\\t\\t\\tx--;\\n\\t\\t\\tprintf(\"%d\", x);\\n\\t\\t}\\n\\t\\tprintf(\"\n\");x = 1;\\n\\t\\t}\\n\\t\\treturn 0;\\n}",
            "OPT_A": "1\\n121\\n12321\\n1234321\\n123454321\\n",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 29,
            "Q_TEXT": "Pattern 5",
            "Q_PRGM": "main()\\n{\\n\\tint i,j,n,temp;\\n\\tprintf(\"enter number of lines\");\\n\\tscanf(\"%d\",&n);\\n\\tj=n*4;\\n\\tfor(i=0,temp=0;i<j;i++,temp++)\\n\\t\\t{\\n\\t\\tif(temp!=4)\\n\\t\\t{\\n\\t\\t\\tprintf(\"%d\",i%10);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tprintf(\"\n%d\",i%10);\\n\\t\\t\\ttemp=0;\\n\\t\\t}\\n\\t\\t}\\n\\treturn 0;\\n\\t}",
            "OPT_A": "1234\n5678\n9012\n3456\n7890",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 30,
            "Q_TEXT": "Pattern 6",
            "Q_PRGM": "#include<stdio.h>\\nint main()\\n{\\n\\tchar prnt = '*';\\n\\t int i, j, nos = 4, s;\\n\\t for(i = 1; i <= 5; i++)\\n\\t{\\n\\t\\tfor(s = nos; s >= 1; s--)\\n\\t\\t{\\n\\t\\t\\tprintf(\"  \");\\n\\t\\t\\tfor (j = 1; j <= i; j++)\\n\\t\\t\\t\\t {\\n\\t\\t\\tprintf(\"%2c\", prnt);\\n\\t\\t}\\n\\t\\t\\tprintf(\"\n\");\\n\\t\\t--nos;\\n\\t}\\n\\treturn 0;\\n}",
            "OPT_A": "\\t\\t\\t*\n\\t\\t**\n\\t***\n****",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          },
          {
            "Q_ID": 31,
            "Q_TEXT": "Selection Sort",
            "Q_PRGM": "#include <stdio.h>\\nint main()\\n{\\n\\tint array[100], n, c, d, position, swap;\\n\\tprintf(\"Enter number of elements\n\");\\n\\tscanf(\"%d\", &n);\\n\\tprintf(\"Enter %d integers\n\", n);\\n\\tfor ( c = 0 ; c < n ; c++ )\\n\\t\\tscanf(\"%d\", &array[c]);\\n\\tfor(c=0;c<(n-1);c++)\\n\\t{\\n\\t\\tposition = c;\\n\\t\\tfor(d=c+1;d<n;d++)\\n\\t\\t{\\n\\t\\t\\tif(array[position] > array[d])\\n\\t\\t\\t\\tposition = d;\\n\\t\\t}\\n\\t\\tif ( position != c )\\n\\t\\t{\\n\\t\\t\\tswap = array[c];\\n\\t\\t\\tarray[c] = array[position];\\n\\t\\t\\tarray[position] = swap;\\n\\t\\t\\t}\\n\\t\\t}\\n\\tprintf(\"Sorted list in ascending order:\n\");\\n\\tfor ( c = 0 ; c < n ; c++ )\\n\\t\\tprintf(\"%d\n\", array[c]);\\n\\treturn 0;\\n\\t}",
            "OPT_A": "Enter number of elements\\n5\\nEnter 5 Integers\\n10\\n7\\n2\\n5\\n1\\nSorted list in ascending order\\n1\\n2\\n5\\n7\\n10\\n",
            "OPT_B": "A",
            "OPT_C": "A",
            "OPT_D": "A",
            "ANSWER": 1
          }
        ]
      },
      {
        "LEVEL_ID": 2,
        "LEVEL_NAME": "Theory",
        "LOCK_STATUS": 1,
        "QUESTIONS": [
          {
            "Q_ID" : 1,
            "Q_TEXT" : "Introduction",
            "Q_PRGM" : "C is a general-purpose, imperative computer programming language, supporting structured programming,lexical variable scope and recursion, while a static type system prevents many unintended operations. By design, C provides constructs that map efficiently to typical machine instructions, and therefore it has found lasting use in applications that had formerly been coded in assembly language, including operating systems, as well as various application software for computers ranging fromsupercomputers to embedded systems.\\nC was originally developed by Dennis Ritchie between 1969 and 1973 at AT&T Bell Labs,and used to re-implement the Unixoperating system. It has since become one of the most widely used programming languages of all time, with C compilers from various vendors available for the majority of existing computer architectures and operating systems. C has been standardized by theAmerican National Standards Institute (ANSI) since 1989 (see ANSI C) and subsequently by the International Organization for Standardization (ISO).",
            "OPT_A" : "C was originally developed by Dennis Ritchie between 1969 and 1973 at AT&T Bell Labs",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 2,
            "Q_TEXT" : "Design",
            "Q_PRGM" : "It was designed to be compiled using a relatively straightforward compiler, to provide low-level access to memory, to provide language constructs that map efficiently to machine instructions, and to require minimal run-time support. C was therefore useful for many applications that had formerly been coded in assembly language, such as in system programming.\\nDespite its low-level capabilities, the language was designed to encourage cross-platform programming. A standards-compliant and portably written C program can be compiled for a very wide variety of computer platforms and operating systems with few changes to its source code. The language has become available on a very wide range of platforms, from embedded microcontrollers to supercomputers.",
            "OPT_A" : "C is an imperative (procedural) language",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 3,
            "Q_TEXT" : "Overview",
            "Q_PRGM" : "Like most imperative languages in the ALGOL tradition, C has facilities for structured programming and allows lexical variable scope and recursion, while a static type systemprevents many unintended operations. In C, all executable code is contained within subroutines, which are called \"functions\" (although not in the strict sense of functional programming). Function parameters are always passed by value. Pass-by-reference is simulated in C by explicitly passing pointer values. C program source text is free-format, using the semicolon as a statement terminator and curly braces for grouping blocks of statements.\\nThe C language also exhibits the following characteristics:\\n	There is a small, fixed number of keywords, including a full set of flow of control primitives: for, if/else, while, switch, and do/while. There is one namespace, and user-defined names are not distinguished from keywords by any kind of sigil.\\n•	There are a large number of arithmetical and logical operators, such as +, +=, ++, &, ~, etc.\\n	More than one assignment may be performed in a single statement.\\n•	Function return values can be ignored when not needed.\\n	Typing is static, but weakly enforced: all data has a type, but implicit conversions can be performed; for instance, characters can be used as integers.\\n	Declaration syntax mimics usage context. C has no \"define\" keyword; instead, a statement beginning with the name of a type is taken as a declaration. There is no \"function\" keyword; instead, a function is indicated by the parentheses of an argument list.\\n	User-defined (typedef) and compound types are possible.\\n	Heterogeneous aggregate data types (struct) allow related data elements to be accessed and assigned as a unit.\\n	Array indexing is a secondary notation, defined in terms of pointer arithmetic. Unlike structs, arrays are not first-class objects; they cannot be assigned or compared using single built-in operators. There is no \"array\" keyword, in use or definition; instead, square brackets indicate arrays syntactically, for example month.\\n	Enumerated types are possible with the enum keyword. They are not tagged, and are freely interconvertible with integers.\\n	Strings are not a separate data type, but are conventionally implemented as null-terminated arrays of characters.\\n	Low-level access to computer memory is possible by converting machine addresses to typed pointers.\\n	Procedures (subroutines not returning values) are a special case of function, with an untyped return type void.\\n	Functions may not be defined within the lexical scope of other functions.\\n	Function and data pointers permit ad hoc run-time polymorphism.\\n	A preprocessor performs macro definition, source code file inclusion, and conditional compilation.\\n	There is a basic form of modularity: files can be compiled separately and linked together, with control over which functions and data objects are visible to other files viastatic and extern attributes.\\n	Complex functionality such as I/O, string manipulation, and mathematical functions are consistently delegated to library routines.\\nC does not include some features found in newer, more modern high-level languages, including object orientation and garbage collection.",
            "OPT_A" : "Pass-by-reference is simulated in C by explicitly passing pointer values.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 4,
            "Q_TEXT" : "Relations to other languages",
            "Q_PRGM" : "Many later languages have borrowed directly or indirectly from C, including C++, D, Go, Rust, Java, JavaScript, Limbo, LPC, C#, Objective-C, Perl, PHP, Python, Verilog(hardware description language), and Unix's C shell. These languages have drawn many of their control structures and other basic features from C. Most of them (with Python being the most dramatic exception) are also very syntactically similar to C in general, and they tend to combine the recognizable expression and statement syntax of C with underlying type systems, data models, and semantics that can be radically different.",
            "OPT_A" : " C++, D, Go, Rust, Java, JavaScript, Limbo, LPC, C#, Objective-C, Perl, PHP, Python, Verilog are derieved using C",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 5,
            "Q_TEXT" : "History",
            "Q_PRGM" : "The origin of C is closely tied to the development of the Unix operating system, originally implemented in assembly language on a PDP-7by Ritchie and Thompson, incorporating several ideas from colleagues. Eventually, they decided to port the operating system to a PDP-11. The original PDP-11 version of Unix was developed in assembly language. The developers were considering rewriting the system using the B language, Thompson's simplified version of BCPL.However B's inability to take advantage of some of the PDP-11's features, notably byte addressability, led to C.\\nThe development of C started in 1972 on the PDP-11 Unix system and first appeared in Version 2 Unix.The language was not initially designed with portability in mind, but soon ran on different platforms as well: a compiler for the Honeywell 6000 was written within the first year of C's history, while an IBM System/370 port followed soon.The name of C simply continued the alphabetic order started by B.\\nAlso in 1972, a large part of Unix was rewritten in C. By 1973, with the addition of struct types, the C language had become powerful enough that most of the Unix's kernel was now in C.\\nUnix was one of the first operating system kernels implemented in a language other than assembly. (Earlier instances include the Multics system (written in PL/I), and MCP (Master Control Program) for the Burroughs B5000 written in ALGOL in 1961.) Circa 1977, Ritchie and Stephen C. Johnson made further changes to the language to facilitate portability of the Unix operating system. Johnson's Portable C Compiler served as the basis for several implementations of C on new platforms.",
            "OPT_A" : " The development of C started in 1972 on the PDP-11 Unix system",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 6,
            "Q_TEXT" : "K&R C",
            "Q_PRGM" : "In 1978, Brian Kernighan and Dennis Ritchie published the first edition of The C Programming Language. This book, known to C programmers as \"K&R\", served for many years as an informal specification of the language. The version of C that it describes is commonly referred to as K&R C. The second edition of the book covers the later ANSI C standard, described below.\\nK&R introduced several language features:\\n•	standard I/O library\\n•	long int data type\\n•	unsigned int data type\\n•	compound assignment operators of the form =op (such as =-) were changed to the form op= (that is, -=) to remove the semantic ambiguity created by such constructs as i=-10, which had been interpreted as i =- 10 (decrement i by 10) instead of the possibly intended i = -10 (let i be -10)\\nEven after the publication of the 1989 ANSI standard, for many years K&R C was still considered the \"lowest common denominator\" to which C programmers restricted themselves when maximum portability was desired, since many older compilers were still in use, and because carefully written K&R C code can be legal Standard C as well.\\nIn early versions of C, only functions that returned a non-int value needed to be declared if used before the function definition; a function used without any previous declaration was assumed to return type int, if its value was used.\\nThe int type specifiers which are commented out could be omitted in K&R C, but are required in later standards.\\nSince K&R function declarations did not include any information about function arguments, function parameter type checks were not performed, although some compilers would issue a warning message if a local function was called with the wrong number of arguments, or if multiple calls to an external function used different numbers or types of arguments. Separate tools such as Unix's lint utility were developed that (among other things) could check for consistency of function use across multiple source files.\\nIn the years following the publication of K&R C, several features were added to the language, supported by compilers from AT&T (in particular PCC) and some other vendors. These included:\\n•	void functions (i.e., functions with no return value)\\n•	functions returning struct or union types (rather than pointers)\\n•	assignment for struct data types\\n•	enumerated types\\nThe large number of extensions and lack of agreement on a standard library, together with the language popularity and the fact that not even the Unix compilers precisely implemented the K&R specification, led to the necessity of standardization.",
            "OPT_A" : " The int type specifiers which are commented out could be omitted in K&R C, but are required in later standards.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 7,
            "Q_TEXT" : "ANSI C and ISO C",
            "Q_PRGM" : "During the late 1970s and 1980s, versions of C were implemented for a wide variety of mainframe computers, minicomputers, and microcomputers, including the IBM PC, as its popularity began to increase significantly.\\nIn 1983, the American National Standards Institute (ANSI) formed a committee, X3J11, to establish a standard specification of C. X3J11 based the C standard on the Unix implementation; however, the non-portable portion of the Unix C library was handed off to the IEEE working group 1003 to become the basis for the 1988 POSIX standard. In 1989, the C standard was ratified as ANSI X3.159-1989 \"Programming Language C\". This version of the language is often referred to as ANSI C, Standard C, or sometimes C89.\\nIn 1990, the ANSI C standard (with formatting changes) was adopted by the International Organization for Standardization (ISO) as ISO/IEC 9899:1990, which is sometimes called C90. Therefore, the terms \"C89\" and \"C90\" refer to the same programming language.\\nANSI, like other national standards bodies, no longer develops the C standard independently, but defers to the international C standard, maintained by the working group ISO/IEC JTC1/SC22/WG14. National adoption of an update to the international standard typically occurs within a year of ISO publication.\\nOne of the aims of the C standardization process was to produce a superset of K&R C, incorporating many of the subsequently introduced unofficial features. The standards committee also included several additional features such as function prototypes (borrowed from C++), void pointers, support for international character sets and locales, and preprocessor enhancements. Although the syntax for parameter declarations was augmented to include the style used in C++, the K&R interface continued to be permitted, for compatibility with existing source code.\\nC89 is supported by current C compilers, and most C code being written today is based on it. Any program written only in Standard C and without any hardware-dependent assumptions will run correctly on any platform with a conforming C implementation, within its resource limits. Without such precautions, programs may compile only on a certain platform or with a particular compiler, due, for example, to the use of non-standard libraries, such as GUI libraries, or to a reliance on compiler- or platform-specific attributes such as the exact size of data types and byte endianness.\\nIn cases where code must be compilable by either standard-conforming or K&R C-based compilers, the __STDC__ macro can be used to split the code into Standard and K&R sections to prevent the use on a K&R C-based compiler of features available only in Standard C.\\nAfter the ANSI/ISO standardization process, the C language specification remained relatively static for several years. In 1995 Normative Amendment 1 to the 1990 C standard (ISO/IEC 9899/AMD1:1995, known informally as C95) was published, to correct some details and to add more extensive support for international character sets.",
            "OPT_A" : " One of the aims of the C standardization process was to produce a superset of K&R C, incorporating many of the subsequently introduced unofficial features.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 8,
            "Q_TEXT" : "C99",
            "Q_PRGM" : "The C standard was further revised in the late 1990s, leading to the publication of ISO/IEC 9899:1999 in 1999, which is commonly referred to as \"C99\". It has since been amended three times by Technical Corrigenda.\\nC99 introduced several new features, including inline functions, several new data types (including long long int and a complex type to represent complex numbers),variable-length arrays and flexible array members, improved support for IEEE 754 floating point, support for variadic macros (macros of variable arity), and support for one-line comments beginning with //, as in BCPL or C++. Many of these had already been implemented as extensions in several C compilers.\\nC99 is for the most part backward compatible with C90, but is stricter in some ways; in particular, a declaration that lacks a type specifier no longer has int implicitly assumed. A standard macro __STDC_VERSION__ is defined with value 199901L to indicate that C99 support is available. GCC, Solaris Studio, and other C compilers now support many or all of the new features of C99. The C compiler in Microsoft Visual C++, however, implements the C89 standard and those parts of C99 that are required for compatibility withC++11.",
            "OPT_A" : " C99 is for the most part backward compatible with C90, but is stricter in some ways.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 9,
            "Q_TEXT" : "C11",
            "Q_PRGM" : "In 2007, work began on another revision of the C standard, informally called \"C1X\" until its official publication on 2011-12-08. The C standards committee adopted guidelines to limit the adoption of new features that had not been tested by existing implementations.\\nThe C11 standard adds numerous new features to C and the library, including type generic macros, anonymous structures, improved Unicode support, atomic operations, multi-threading, and bounds-checked functions. It also makes some portions of the existing C99 library optional, and improves compatibility with C++. The standard macro__STDC_VERSION__ is defined as 201112L to indicate that C11 support is available.",
            "OPT_A" : " It makes some portions of the existing C99 library optional, and improves compatibility with C++.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 10,
            "Q_TEXT" : "Embedded C",
            "Q_PRGM" : "Historically, embedded C programming requires nonstandard extensions to the C language in order to support exotic features such as fixed-point arithmetic, multiple distinct memory banks, and basic I/O operations.\\nIn 2008, the C Standards Committee published a technical report extending the C language to address these issues by providing a common standard for all implementations to adhere to. It includes a number of features not available in normal C, such as fixed-point arithmetic, named address spaces, and basic I/O hardware addressing.",
            "OPT_A" : "In 2008, the C Standards Committee published a technical report extending the C language",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 11,
            "Q_TEXT" : "Syntax",
            "Q_PRGM" : "C has a formal grammar specified by the C standard. Unlike languages such as FORTRAN 77, C source code is free-form which allows arbitrary use of whitespace to format code, rather than column-based or text-line-based restrictions. (Line boundaries do have significance during the preprocessing phase.) Comments may appear either between the delimiters /* and */, or (since C99) following // until the end of the line. Comments delimited by /* and */ do not nest, and these sequences of characters are not interpreted as comment delimiters if they appear inside string or character literals.\\nC source files contain declarations and function definitions. Function definitions, in turn, contain declarations and statements. Declarations either define new types using keywords such as struct, union, and enum, or assign types to and perhaps reserve storage for new variables, usually by writing the type followed by the variable name. Keywords such as char and int specify built-in types. Sections of code are enclosed in braces ({ and }, sometimes called \"curly brackets\") to limit the scope of declarations and to act as a single statement for control structures.\\nAs an imperative language, C uses statements to specify actions. The most common statement is an expression statement, consisting of an expression to be evaluated, followed by a semicolon; as a side effect of the evaluation, functions may be called and variables may be assigned new values. To modify the normal sequential execution of statements, C provides several control-flow statements identified by reserved keywords. Structured programming is supported by if(-else) conditional execution and by do-while,while, and for iterative execution (looping). The for statement has separate initialization, testing, and reinitialization expressions, any or all of which can be omitted.break and continue can be used to leave the innermost enclosing loop statement or skip to its reinitialization. There is also a non-structured goto statement which branches directly to the designated label within the function. switch selects a case to be executed based on the value of an integer expression.\\nExpressions can use a variety of built-in operators and may contain function calls. The order in which arguments to functions and operands to most operators are evaluated is unspecified. The evaluations may even be interleaved. However, all side effects (including storage to variables) will occur before the next \"sequence point\"; sequence points include the end of each expression statement, and the entry to and return from each function call. Sequence points also occur during evaluation of expressions containing certain operators (&&, ||, ?: and the comma operator). This permits a high degree of object code optimization by the compiler, but requires C programmers to take more care to obtain reliable results than is needed for other programming languages.\\nKernighan and Ritchie say in the Introduction of The C Programming Language: \"C, like any other language, has its blemishes. Some of the operators have the wrong precedence; some parts of the syntax could be better.\" The C standard did not attempt to correct many of these blemishes, because of the impact of such changes on already existing software.",
            "OPT_A" : "C source files contain declarations and function definitions.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 12,
            "Q_TEXT" : "Character set",
            "Q_PRGM" :"The character set is the fundamental raw material of any language and they are used to represent information. Like natural languages, computer language will also have well defined character set, which is useful to build the programs. ",
            "OPT_A" : "The basic C execution character set contains the same characters, along with representations for alert, backspace, and carriage return. Run-time support for extended character sets has increased with each revision of the C standard.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 13,
            "Q_TEXT" : "Keywords",
            "Q_PRGM" : "C89 has 32 keywords (reserved words with special meaning):\\nauto\\tbreak\\tcase\\nchar\\tconst\\tcontinue\\ndefault\\tdo\\tdouble\\nelse\\tenum\\textern\\nfloat\\tfor\\tgoto\\nif\\tint\\tlong\\nregister\\treturn\\tshort\\nsigned\\tsizeof\\tstatic\\nstruct\\tswitch\\ttypedef\\nunion\\tunsigned\\tvoid\\nvolatile\\twhile\\nC99 adds five more keywords:\\n_Bool\\t_Complex\\t_Imaginary\\ninline\\trestrict\\nC11 adds seven more keywords:\\n_Alignas\\t_Alignof\\t_Atomic\\n_Generic\\t_Noreturn\\t_Static_assert\\n_Thread_local\\nMost of the recently added keywords begin with an underscore followed by a capital letter, because identifiers of that form were previously reserved by the C standard for use only by implementations. Since existing program source code should not have been using these identifiers, it would not be affected when C implementations started supporting these extensions to the programming language. Some standard headers do define more convenient synonyms for underscored identifiers.",
            "OPT_A" : "The language previously included a reserved keyword called entry, but this was seldom implemented, and has now been removed as a reserved word.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 14,
            "Q_TEXT" : "Operators",
            "Q_PRGM" : "C supports a rich set of operators, which are symbols used within an expression to specify the manipulations to be performed while evaluating that expression. C has operators for:\\n•	arithmetic: +, -, *, /, %\\n•	assignment: =\\n•	augmented assignment: +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=\\n•	bitwise logic: ~, &, |, ^\\n•	bitwise shifts: <<, >>\\n•	boolean logic: !, &&, ||\\n•	conditional evaluation: ? :\\n•	equality testing: ==, !=\\n•	calling functions: ( )\\n•	increment and decrement: ++, --\\n•	member selection: ., ->\\n•	object size: sizeof\\n•	order relations: <, <=, >, >=\\n•	reference and dereference: &, *, [,]\\n•	sequencing: ,\\n•	subexpression grouping: ( )•	type conversion: (typename)\\nC uses the = operator, reserved in mathematics to express equality, to indicate assignment, following the precedent of Fortran and PL/I, but unlike ALGOL and its derivatives. The similarity between C's operator for assignment and that for equality (==) has been criticized[by whom?] as it makes it easy to accidentally substitute one for the other. In many cases, each may be used in the context of the other without a compilation error (although some compilers produce warnings). For example, the conditional expression inif(a=b+1) is true if a is not zero after the assignment. Additionally, C's operator precedence is non-intuitive, such as == binding more tightly than & and | in expressions like x & 1 == 0, which would need to be written (x & 1) == 0 to be properly evaluated.",
            "OPT_A" : "C uses the = operator, reserved in mathematics to express equality, to indicate assignment, following the precedent of Fortran and PL/I, but unlike ALGOL and its derivatives.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 15,
            "Q_TEXT" : "Data types",
            "Q_PRGM" : "The type system in C is static and weakly typed, which makes it similar to the type system of ALGOL descendants such as Pascal. There are built-in types for integers of various sizes, both signed and unsigned, floating-point numbers, characters, and enumerated types (enum). C99 added a boolean datatype. There are also derived types including arrays, pointers, records (struct), and untagged unions (union).\\nC is often used in low-level systems programming where escapes from the type system may be necessary. The compiler attempts to ensure type correctness of most expressions, but the programmer can override the checks in various ways, either by using a type cast to explicitly convert a value from one type to another, or by using pointers or unions to reinterpret the underlying bits of a data object in some other way.\\nSome find C's declaration syntax unintuitive, particularly for function pointers. (Ritchie's idea was to declare identifiers in contexts resembling their use: \"declaration reflects use\".)\\nC's usual arithmetic conversions allow for efficient code to be generated, but can sometimes produce unexpected results. For example, a comparison of signed and unsigned integers of equal width requires a conversion of the signed value to unsigned. This can generate unexpected results if the signed value is negative.",
            "OPT_A" : "Some find C's declaration syntax unintuitive, particularly for function pointers. ",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 16,
            "Q_TEXT" : "Pointers",
            "Q_PRGM" : "C supports the use of pointers, a type of reference that records the address or location of an object or function in memory. Pointers can be dereferenced to access data stored at the address pointed to, or to invoke a pointed-to function. Pointers can be manipulated using assignment or pointer arithmetic. The run-time representation of a pointer value is typically a raw memory address (perhaps augmented by an offset-within-word field), but since a pointer's type includes the type of the thing pointed to, expressions including pointers can be type-checked at compile time. Pointer arithmetic is automatically scaled by the size of the pointed-to data type. Pointers are used for many purposes in C. Text strings are commonly manipulated using pointers into arrays of characters. Dynamic memory allocation is performed using pointers. Many data types, such as trees, are commonly implemented as dynamically allocated struct objects linked together using pointers. Pointers to functions are useful for passing functions as arguments to higher-order functions (such as qsort or bsearch) or as callbacks to be invoked by event handlers.\\nA null pointer value explicitly points to no valid location. Dereferencing a null pointer value is undefined, often resulting in a segmentation fault. Null pointer values are useful for indicating special cases such as no \"next\" pointer in the final node of a linked list, or as an error indication from functions returning pointers. In appropriate contexts in source code, such as for assigning to a pointer variable, a null pointer constant can be written as 0, with or without explicit casting to a pointer type, or as the NULL macro defined by several standard headers. In conditional contexts, null pointer values evaluate to false, while all other pointer values evaluate to true.\\nVoid pointers (void *) point to objects of unspecified type, and can therefore be used as \"generic\" data pointers. Since the size and type of the pointed-to object is not known, void pointers cannot be dereferenced, nor is pointer arithmetic on them allowed, although they can easily be (and in many contexts implicitly are) converted to and from any other object pointer type.\\nCareless use of pointers is potentially dangerous. Because they are typically unchecked, a pointer variable can be made to point to any arbitrary location, which can cause undesirable effects. Although properly used pointers point to safe places, they can be made to point to unsafe places by using invalid pointer arithmetic; the objects they point to may be deallocated and reused (dangling pointers); they may be used without having been initialized (wild pointers); or they may be directly assigned an unsafe value using a cast, union, or through another corrupt pointer. In general, C is permissive in allowing manipulation of and conversion between pointer types, although compilers typically provide options for various levels of checking. Some other programming languages address these problems by using more restrictive reference types.",
            "OPT_A" : "Void pointers (void *) point to objects of unspecified type, and can therefore be used as \"generic\" data pointers. ",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 17,
            "Q_TEXT" : "Arrays",
            "Q_PRGM" : "Array types in C are traditionally of a fixed, static size specified at compile time. (The more recent C99 standard also allows a form of variable-length arrays.) However, it is also possible to allocate a block of memory (of arbitrary size) at run-time, using the standard library's malloc function, and treat it as an array. C's unification of arrays and pointers means that declared arrays and these dynamically allocated simulated arrays are virtually interchangeable.\\nSince arrays are always accessed (in effect) via pointers, array accesses are typically not checked against the underlying array size, although some compilers may providebounds checking as an option. Array bounds violations are therefore possible and rather common in carelessly written code, and can lead to various repercussions, including illegal memory accesses, corruption of data, buffer overruns, and run-time exceptions. If bounds checking is desired, it must be done manually.\\nC does not have a special provision for declaring multidimensional arrays, but rather relies on recursion within the type system to declare arrays of arrays, which effectively accomplishes the same thing. The index values of the resulting \"multidimensional array\" can be thought of as increasing in row-major order.\\nMultidimensional arrays are commonly used in numerical algorithms (mainly from applied linear algebra) to store matrices. The structure of the C array is well suited to this particular task. However, since arrays are passed merely as pointers, the bounds of the array must be known fixed values or else explicitly passed to any subroutine that requires them, and dynamically sized arrays of arrays cannot be accessed using double indexing. (A workaround for this is to allocate the array with an additional \"row vector\" of pointers to the columns.)\\nC99 introduced \"variable-length arrays\" which address some, but not all, of the issues with ordinary C arrays.",
            "OPT_A" : "C does not have a special provision for declaring multidimensional arrays, but rather relies on recursion within the type system to declare arrays of arrays, which effectively accomplishes the same thing. ",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 18,
            "Q_TEXT" : "Array–pointer interchangeability",
            "Q_PRGM" : "The subscript notation x[i] (where x designates a pointer) is a syntactic sugar for *(x+i).[31] Taking advantage of the compiler's knowledge of the pointer type, the address that x + i points to is not the base address (pointed to by x) incremented by i bytes, but rather is defined to be the base address incremented by i multiplied by the size of an element that x points to. Thus, x[i] designates the i+1th element of the array.\\nFurthermore, in most expression contexts (a notable exception is as operand of sizeof), the name of an array is automatically converted to a pointer to the array's first element. This implies that an array is never copied as a whole when named as an argument to a function, but rather only the address of its first element is passed. Therefore, although function calls in C use pass-by-value semantics, arrays are in effect passed by reference.\\nThe size of an element can be determined by applying the operator sizeof to any dereferenced element of x, as in n = sizeof *x or n = sizeof x[0], and the number of elements in a declared array A can be determined as sizeof A / sizeof A[0]. The latter only applies to array names: variables declared with subscripts (int A[20]). Due to the semantics of C, it is not possible to determine the entire size of arrays through pointers to arrays or those created by dynamic allocation (malloc); code such assizeof arr / sizeof arr[0] (where arr designates a pointer) will not work since the compiler assumes the size of the pointer itself is being requested. Since array name arguments to sizeof are not converted to pointers, they do not exhibit such ambiguity. However, arrays created by dynamic allocation are accessed by pointers rather than true array variables, so they suffer from the same sizeof issues as array pointers.\\nThus, despite this apparent equivalence between array and pointer variables, there is still a distinction to be made between them. Even though the name of an array is, in most expression contexts, converted into a pointer (to its first element), this pointer does not itself occupy any storage; the array name is not an l-value, and its address is a constant, unlike a pointer variable. Consequently, what an array \"points to\" cannot be changed, and it is impossible to assign a new address to an array name. Array contents may be copied, however, by using the memcpy function, or by accessing the individual elements.",
            "OPT_A" : " Due to the semantics of C, it is not possible to determine the entire size of arrays through pointers to arrays or those created by dynamic allocation (malloc) ",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 19,
            "Q_TEXT" : "Memory management",
            "Q_PRGM" : "One of the most important functions of a programming language is to provide facilities for managing memory and the objects that are stored in memory. C provides three distinct ways to allocate memory for objects:\\n•	Static memory allocation: space for the object is provided in the binary at compile-time; these objects have an extent (or lifetime) as long as the binary which contains them is loaded into memory.\\n•	Automatic memory allocation: temporary objects can be stored on the stack, and this space is automatically freed and reusable after the block in which they are declared is exited.\\n•	Dynamic memory allocation: blocks of memory of arbitrary size can be requested at run-time using library functions such as malloc from a region of memory called theheap; these blocks persist until subsequently freed for reuse by calling the library function realloc or free\\nThese three approaches are appropriate in different situations and have various tradeoffs. For example, static memory allocation has little allocation overhead, automatic allocation may involve slightly more overhead, and dynamic memory allocation can potentially have a great deal of overhead for both allocation and deallocation. The persistent nature of static objects is useful for maintaining state information across function calls, automatic allocation is easy to use but stack space is typically much more limited and transient than either static memory or heap space, and dynamic memory allocation allows convenient allocation of objects whose size is known only at run-time. Most C programs make extensive use of all three.\\nWhere possible, automatic or static allocation is usually simplest because the storage is managed by the compiler, freeing the programmer of the potentially error-prone chore of manually allocating and releasing storage. However, many data structures can change in size at runtime, and since static allocations (and automatic allocations before C99) must have a fixed size at compile-time, there are many situations in which dynamic allocation is necessary. Prior to the C99 standard, variable-sized arrays were a common example of this. (See the article on malloc for an example of dynamically allocated arrays.) Unlike automatic allocation, which can fail at run time with uncontrolled consequences, the dynamic allocation functions return an indication (in the form of a null pointer value) when the required storage cannot be allocated. (Static allocation that is too large is usually detected by the linker or loader, before the program can even begin execution.)\\nUnless otherwise specified, static objects contain zero or null pointer values upon program startup. Automatically and dynamically allocated objects are initialized only if an initial value is explicitly specified; otherwise they initially have indeterminate values (typically, whatever bit pattern happens to be present in the storage, which might not even represent a valid value for that type). If the program attempts to access an uninitialized value, the results are undefined. Many modern compilers try to detect and warn about this problem, but both false positives and false negatives can occur.\\nAnother issue is that heap memory allocation has to be synchronized with its actual usage in any program in order for it to be reused as much as possible. For example, if the only pointer to a heap memory allocation goes out of scope or has its value overwritten before free() is called, then that memory cannot be recovered for later reuse and is essentially lost to the program, a phenomenon known as a memory leak. Conversely, it is possible for memory to be freed but continue to be referenced, leading to unpredictable results. Typically, the symptoms will appear in a portion of the program far removed from the actual error, making it difficult to track down the problem. (Such issues are ameliorated in languages with automatic garbage collection.)",
            "OPT_A" : " Static allocation that is too large is usually detected by the linker or loader, before the program can even begin execution.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          }
        ]
      },
      {
        "LEVEL_ID": 3,
        "LEVEL_NAME": "Miscellaneous",
        "LOCK_STATUS": 1,
        "QUESTIONS": [
          {
            "Q_ID": 1,
            "Q_TEXT": "1. What is the output of this C code ?",
            "Q_PRGM": "#include <stdio.h> \\nmain()\\n{\\nchar *p = 0; \\n*p = 'a';\\n printf(\"value in pointer p is %c\", *p);\\n}",
            "OPT_A": "It will print a",
            "OPT_B": "It will print 0",
            "OPT_C": "Compile time error",
            "OPT_D": "Run time error",
            "ANSWER": 4
          },
          {
            "Q_ID": 2,
            "Q_TEXT": "What is the output of this C code?",
            "Q_PRGM": "#include <stdio.h>\\nmain()\\n{\\nchar *p = \"Sanfoundry C-Test\";\\np[0] = 'a';\\np[1] = 'b';\\nprintf(\"%s\", p);\\n}",
            "OPT_A": "abnfoundry C-Test",
            "OPT_B": "Sanfoundry C-Test",
            "OPT_C": "Compile time error",
            "OPT_D": "Run time error",
            "ANSWER": 4
          },
          {
            "Q_ID": 3,
            "Q_TEXT": "Which of the following is not a valid variable name declaration?",
            "Q_PRGM": "",
            "OPT_A": "int__a3;",
            "OPT_B": "int__3a;",
            "OPT_C": "int__A3;",
            "OPT_D": "int 3_a;",
            "ANSWER": 4
          },
          {
            "Q_ID": 4,
            "Q_TEXT": "Variable name resolving (number of significant characters for uniqueness of variable) depends  on",
            "Q_PRGM": "",
            "OPT_A": "Compiler and linker implementations",
            "OPT_B": "Assemblers and loaders implementations",
            "OPT_C": "C language",
            "OPT_D": "None",
            "ANSWER": 1
          },
          {
            "Q_ID": 5,
            "Q_TEXT": "The format identifier ‘%i’ is also used for _____ data type?",
            "Q_PRGM": "",
            "OPT_A": "char",
            "OPT_B": "int",
            "OPT_C": "float",
            "OPT_D": "double",
            "ANSWER": 2
          },
          {
            "Q_ID": 6,
            "Q_TEXT": "Which data type is most suitable for storing a number 65000 in a 32-bit system?",
            "Q_PRGM": "",
            "OPT_A": "signed short",
            "OPT_B": "unsigned short",
            "OPT_C": "long",
            "OPT_D": "int",
            "ANSWER": 2
          },
          {
            "Q_ID": 7,
            "Q_TEXT": "Which of the following is a User-defined data type?",
            "Q_PRGM": "",
            "OPT_A": "typedef int Boolean;",
            "OPT_B": "typedef enum {Mon, Tue, Wed, Thu, Fri} Workdays;",
            "OPT_C": "struct {char name[10], int age};",
            "OPT_D": "all of the mentioned",
            "ANSWER": 4
          },
          {
            "Q_ID": 8,
            "Q_TEXT": "What is short int in C programming?",
            "Q_PRGM": "",
            "OPT_A": "Basic datatype of C",
            "OPT_B": "Qualifier",
            "OPT_C": "short is the qualifier and int is the basic datatype",
            "OPT_D": "All of the mentioned",
            "ANSWER": 3
          },
          {
            "Q_ID": 9,
            "Q_TEXT": "When double is converted to float, the value is?",
            "Q_PRGM": "",
            "OPT_A": "Truncated",
            "OPT_B": "Rounded",
            "OPT_C": "Depends on the compiler",
            "OPT_D": "Depends on the standard",
            "ANSWER": 3
          },
          {
            "Q_ID": 10,
            "Q_TEXT": "For which of the following, “PI++;” code will fail?",
            "Q_PRGM": "",
            "OPT_A": "#define PI 3.14",
            "OPT_B": "char *PI = “A”;",
            "OPT_C": "float PI = 3.14;",
            "OPT_D": "None of the Mentioned",
            "ANSWER": 1
          },
          {
            "Q_ID": 11,
            "Q_TEXT": "What is the output of this C code?",
            "Q_PRGM": "#include <stdio.h>\\nmain()\\n{int a = 10, b = 10;\\nif (a = 5)\\n\\tb--;\\nprintf(\"%d, %d\", a, b--);\\n}",
            "OPT_A": "a = 10, b = 9",
            "OPT_B": "a = 10, b = 8",
            "OPT_C": "a = 5, b = 9",
            "OPT_D": "a = 5, b = 8",
            "ANSWER": 3
          },

          {
            "Q_ID": 12,
            "Q_TEXT": "Which of the following cannot be used as LHS of the expression in for (exp1;exp2; exp3) ?",
            "Q_PRGM": "",
            "OPT_A": "Variable",
            "OPT_B": "Function",
            "OPT_C": "typedef",
            "OPT_D": "macros",
            "ANSWER": 4
          },
          {
            "Q_ID": 13,
            "Q_TEXT": "Which keyword can be used for coming out of recursion?",
            "Q_PRGM": "",
            "OPT_A": "break",
            "OPT_B": "return",
            "OPT_C": "exit",
            "OPT_D": "Both (a) and (b)",
            "ANSWER": 2
          },

          {
            "Q_ID": 14,
            "Q_TEXT": "Which of the following are correct syntaxes to send an array as a parameter to function:",
            "Q_PRGM": "",
            "OPT_A": "func(&array);",
            "OPT_B": "func(array);",
            "OPT_C": "func(*array);",
            "OPT_D": "Both a & b",
            "ANSWER": 4
          },
          {
            "Q_ID": 15,
            "Q_TEXT": "Which of the following is not possible under any scenario?",
            "Q_PRGM": "",
            "OPT_A": "s1 = &s2;",
            "OPT_B": "s1 = s2;",
            "OPT_C": "(*s1).number = 10;",
            "OPT_D": "None of the mentioned",
            "ANSWER": 4
          },
          {
            "Q_ID": 16,
            "Q_TEXT": "Which of the following operation is illegal in structures?",
            "Q_PRGM": "",
            "OPT_A": "Typecasting of structure",
            "OPT_B": "Pointer to a variable of same structure",
            "OPT_C": "Dynamic allocation of memory for structure",
            "OPT_D": "All of the mentioned",
            "ANSWER": 1
          },
          {
            "Q_ID": 17,
            "Q_TEXT": "Presence of code like “s.t.b = 10” indicate.",
            "Q_PRGM": "",
            "OPT_A": "Syntax Error",
            "OPT_B": "structure",
            "OPT_C": "double data type",
            "OPT_D": "An ordinary variable name",
            "ANSWER": 2
          },
          {
            "Q_ID": 18,
            "Q_TEXT": "What does this statement printf(“%10s”, state); means?",
            "Q_PRGM": "",
            "OPT_A": "10 spaces before the string state is printed",
            "OPT_B": "Print empty spaces if the string state is less than 10 characters",
            "OPT_C": "Print the last 10 characters of the string",
            "OPT_D": "None of the mentioned",
            "ANSWER": 2
          },
          {
            "Q_ID": 19,
            "Q_TEXT": "What is the output of this C code?",
            "Q_PRGM": "#include <stdio.h>\\nint main()\\n{\\nint i = 10, j = 2;\\nprintf(\"%d\", printf(\"%d %d \", i, j));\\n}",
            "OPT_A": "Compile time error",
            "OPT_B": "10 2 4",
            "OPT_C": "10 2 2",
            "OPT_D": "10 2 5",
            "ANSWER": 4
          },
          {
            "Q_ID": 20,
            "Q_TEXT": "The function ____ obtains block of memory dynamically.",
            "Q_PRGM": "",
            "OPT_A": "calloc",
            "OPT_B": "malloc",
            "OPT_C": "Both a & b",
            "OPT_D": "free",
            "ANSWER": 3
          }
        ]
      }
    ]
  },
  {
    "CAT_ID": 2,
    "CAT_NAME": "C++",
    "LEVELS": [
      {
        "LEVEL_ID": 1,
        "LEVEL_NAME": "Practical",
        "LOCK_STATUS": 1,
        "QUESTIONS": [
          {
            "Q_ID" : 1 ,
            "Q_TEXT" : "Analyse the sizeof datatypes",
            "Q_PRGM" : "#include <iostream.h>\\nusing namespace std;\\nint main()\\n{\\n\\tcout <<\"Size of char : \" << sizeof(char) << endl;\\n\\tcout <<\"Size of int : \" << sizeof(int) << endl;\\n\\tcout <<\"Size of short int : \" << sizeof(short int) << endl;\\n\\tcout << \"Size of long int : \" << sizeof(long int) << endl;\\n\\tcout << \"Size of float : \" << sizeof(float) << endl;\\n\\tcout << \"Size of double : \" << sizeof(double) << endl;\\n\\tcout << \"Size of wchar_t : \" << sizeof(wchar_t) << endl;\\n\\treturn 0;\\n\\t}",
            "OPT_A" : "Size of char : 1\\nSize of int : 4\\nSize of short int : 2\\nSize of long int : 4\\nSize of float : 4\\nSize of double : 8\\nSize of wchar_t : 4",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 2 ,
            "Q_TEXT" : "Arithmetic Functions",
            "Q_PRGM" : "#include<iostream.h>\\nusing namespace std;\\nextern int a, b;\\nextern int c;\\nextern float f;\\nint main ()\\n{\\n\\tint a, b;\\n\\tint c;\\n\\tfloat f;\\n\\ta = 10;\\n\\tb = 20;\\n\\tc = a + b;\\n\\tcout << c << endl ;\\n\\tf = 70.0/3.0;\\n\\tcout << f << endl ;\\n\\treturn 0;}",
            "OPT_A" : "30\\n23.3333",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 3 ,
            "Q_TEXT" : "Local and global variables",
            "Q_PRGM" : "#include <iostream.h>\\nusing namespace std;\\nint g=20;\\nint main()\\n{\\n\\tint g=10;\\n\\tcout<<g;\\n\\treturn 0;\\n\\t}",
            "OPT_A" : "10",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 4 ,
            "Q_TEXT" : "Constants and Literals",
            "Q_PRGM" : "#include <iostream.h>\\nusing namespace std;\\nint main()\\n{\\n\\tconst int LENGTH = 10;\\n\\tconst int  WIDTH  = 5;\\n\\tconst char NEWLINE = '\n';\\n\\tint area;\\n\\tarea = LENGTH * WIDTH;\\n\\tcout << area;\\n\\tcout << NEWLINE;\\n\\treturn 0;}",
            "OPT_A" : "50",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 5 ,
            "Q_TEXT" : "difference between signed and unsigned integers.",
            "Q_PRGM" : "#include <iostream.h>\\nusing namespace std;\\nint main()\\n{\\n\\tshort int i;\\n\\tshort unsigned int j;\\n\\tj = 50000;\\n\\ti = j;\\n\\tcout<<i<<\" \"<<j;\\n\\treturn 0;}",
            "OPT_A" : "-15536 50000",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 6 ,
            "Q_TEXT" : "Static Variables and Functions",
            "Q_PRGM" : "#include <iostream.h>\\nvoid func(void);\\nstatic int count = 10;\\nmain()\\n{\\n\\twhile(count--)\\n\\t{\\n\\t\\tfunc();\\n\\t}\\n\\treturn 0;\\n}\\nvoid func( void )\\n{\\n\\tstatic int i = 5;\\n\\ti++;\\n\\tstd::cout << \"i is \" << i ;\\n\\tstd::cout <<\" and count is \" << count << std::endl;\\n",
            "OPT_A" : "i is 6 and count is 9\\ni is 7 and count is 8\\ni is 8 and count is 7\\ni is 9 and count is 6\\ni is 10 and count is 5\\ni is 11 and count is 4\\ni is 12 and count is 3\\ni is 13 and count is 2\\ni is 14 and count is 1\\ni is 15 and count is 0\\n",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 7 ,
            "Q_TEXT" : "Maximum of two numbers",
            "Q_PRGM" : "#include <iostream.h>\\nusing namespace std;\\nint max(int num1, int num2);\\nint main ()\\n{\\n\\tint a = 100;\\n\\tint b = 200;\\n\\tint ret;\\n\\tret = max(a, b);\\n\\tcout <<\"Max value is : \" << ret << endl;\\n\\treturn 0;\\n\\t}\\nint max(int num1, int num2)\\n {\\n\\tint result;\\n\\tif (num1 > num2)\\n\\t\\tresult = num1;\\n\\telse\\n\\t\\tresult = num2;\\n\\treturn result;\\n\\t }",
            "OPT_A" : "200",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 8 ,
            "Q_TEXT" : "Addition of numbers using function",
            "Q_PRGM" : "#include <iostream.h>\\nusing namespace std;\\nint sum(int a, int b=20)\\n{\\n\\tint result;\\n\\tresult = a + b;\\n\\treturn (result);\\n\\t}\\nint main()\\n{\\n\\tint a = 100;\\n\\tint b = 200;\\n\\tint result;\\n\\tresult = sum(a, b);\\n\\tcout <<\"Total value is :\" << result << endl;\\n\\tresult = sum(a);\\n\\tcout << \"Total value is :\" << result << endl;\\n\\treturn 0;\\n\\t}",
            "OPT_A" : "Total value is :300\\nTotal value is :120",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 9 ,
            "Q_TEXT" : "Ceil Floor Square Root Functions",
            "Q_PRGM" : "#include<iostream.h>\\n#include<cmath.h>\\nusing namespace std;\\nint main()\\n{\\n\\tshort s = 10;\\n\\tint i=-1000;\\n\\tlong l=100000;\\n\\tfloat f=230.47;\\n\\tdouble d = 200.374;\\n\\tcout<<\"sin(d) :\"<<sin(d)<<endl;\\n\\tcout<<\"abs(i) :\"<<abs(i)<<endl;\\n\\tcout<<\"floor(d) :\"<<floor(d)<<endl;\\n\\tcout<<\"sqrt(f) :\"<<sqrt(f)<<endl;\\n\\tcout<<\"pow( d, 2) :\" <<pow(d, 2)<<endl;\\n\\treturn 0;\\n}",
            "OPT_A" : "sign(d) :-0.634939\\nabs(i) :1000\\nfloor(d) :200\\nsqrt(f) :15.1812\\npow( d, 2 ) :40149.7",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 10 ,
            "Q_TEXT" : "Random Function",
            "Q_PRGM" : "#include <iostream.h>\\n#include <ctime.h>\\n#include <cstdlib.h>\\nusing namespace std;\\nint main()\\n{\\n\\tint i,j;\\n\\tsrand( (unsigned)time(NULL));\\n\\tfor(i=0;i<10;i++)\\n\\t{\\n\\t\\tj=rand();\\n\\t\\tcout<<\"Random Number:\" << j << endl;\\n\\t\\t}\\n\\treturn 0;\\n}",
            "OPT_A" : "Random Number : 1748144778\\nRandom Number : 630873888\\nRandom Number : 2134540646\\nRandom Number : 219404170\\nRandom Number : 902129458\\nRandom Number : 920445370\\nRandom Number : 1319072661\\nRandom Number : 257938873R\\nandom Number : 1256201101\\nRandom Number : 580322989",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 11 ,
            "Q_TEXT" : "Concept of arrays",
            "Q_PRGM" : "#include <iostream.h>\\nusing namespace std;\\n#include <iomanip.h>\\nusing std::setw;\\nint main ()\\n{\\n\\tint n[10];\\n\\tfor(int i=0;i<10;i++)\\n\\t{\\n\\t\\tn[i]=i+100;\\n\\t}\\n\\tcout<<\"Element\"<<setw(13)<<\"Value\"<<endl;\\n\\tfor(int j=0;j<10;j++)\\n\\t{\\n\\t\\tcout<<setw(7)<<j<<setw(13)<<n[j]<<endl;\\n\\t}\\n\\treturn 0;\\n}",
            "OPT_A" : "Element\\t\\tValue\\n0\\t\\t100\\n1\\t\\t101\\n2\\t\\t102\\n3\\t\\t103\\n4\\t\\t104\\n5\\t\\t105\\n6\\t\\t106\\n7\\t\\t107\\n8\\t\\t108\\n9\\t\\t109\\n",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 12 ,
            "Q_TEXT" : "String Functions",
            "Q_PRGM" : "#include<iostream.h>\\n#include<cstring.h>\\nusing namespace std;\\nint main()\\n{\\n\\tchar str1[10] =\"Hello\";\\n\\tchar str2[10]=\"World\";\\n\\tchar str3[10];\\n\\tint  len ;\\n\\tstrcpy( str3, str1);\\n\\tcout <<\"strcpy( str3, str1) : \" << str3 << endl;\\n\\tstrcat( str1, str2);\\n\\tcout <<\"strcat( str1, str2):\" << str1 << endl;\\n\\tlen = strlen(str1);\\n\\tcout <<\"strlen(str1) : \" << len << endl;\\n\\treturn 0;\\n}",
            "OPT_A" : "strcpy( str3, str1) : Hello\\nstrcat( str1, str2): HelloWorld\\nstrlen(str1) : 10",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 13 ,
            "Q_TEXT" : "Date and Time Functions",
            "Q_PRGM" : "#include <iostream.h>\\n#include <ctime.h>\\nusing namespace std;\\nint main( )\\n{\\n\\ttime_t now = time(0);\\n\\tchar* dt = ctime(&now);\\n\\tcout <<\"The local date and time is: \" << dt << endl;\\n\\ttm *gmtm = gmtime(&now);\\n\\tdt = asctime(gmtm);\\n\\tcout <<\"The UTC date and time is:\"<< dt << endl;\\n}",
            "OPT_A" : "The local date and time is: Sat Jan  20 20:07:41 2016\\nThe UTC date and time is:Sun Jan  21 03:07:41 2016",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 14 ,
            "Q_TEXT" : "Date & Time",
            "Q_PRGM" : "#include <iostream.h>\\n#include <ctime.h>\\nusing namespace std;\\nint main( )\\n{\\n\\ttime_t now = time(0);\\n\\tcout <<\"Number of sec since January 1,1970:\" << now << endl;\\n\\ttm *ltm = localtime(&now);\\n\\tcout <<\"Year: \"<< 1900 + ltm->tm_year << endl;\\n\\tcout <<\"Month: \"<< 1 + ltm->tm_mon<< endl;\\n\\tcout <<\"Day: \"<<  ltm->tm_mday << endl;\\n\\tcout <<\"Time: \"<< 1 + ltm->tm_hour <<\":\";\\n\\tcout << 1 + ltm->tm_min <<\":\";\\n\\tcout << 1 + ltm->tm_sec << endl;\\n}",
            "OPT_A" : "Number of sec since January 1, 1970:1294548238\\nYear: 2016\\nMonth: 1\\nDay: 8\\nTime: 22: 44:59\\n",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 15 ,
            "Q_TEXT" : "Classes and Objects",
            "Q_PRGM" : "#include <iostream.h>\\nusing namespace std;\\nclass Box\\n{\\n\\tpublic:\\n\\t\\tdouble length;\\n\\t\\tdouble breadth;\\n\\t\\tdouble height;\\n};\\nint main()\\n{\\nBox Box1;\\n\\tBox Box2;\\n\\tdouble volume =0.0;\\n\\tBox1.height = 5.0;\\n\\tBox1.length = 6.0;\\n\\tBox1.breadth = 7.0;\\n\\tBox2.height = 10.0;\\n\\tBox2.length = 12.0;\\n\\tBox2.breadth = 13.0;\\n\\tvolume = Box1.height * Box1.length * Box1.breadth;\\n\\tcout <<\"Volume of Box1 : \"<<volume <<endl;\\n\\tvolume = Box2.height * Box2.length * Box2.breadth;\\n\\tcout << \"Volume of Box2 : \" << volume <<endl;\\n\\treturn 0;\\n}",
            "OPT_A" : "Volume of Box1 : 210\\nVolume of Box2 : 1560",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 16 ,
            "Q_TEXT" : "Single Inheritance",
            "Q_PRGM" : "#include <iostream.h>\\nusing namespace std;\\nclass Shape\\n{\\n\\tpublic:\\n\\t\\tvoid setWidth(int w)\\n\\t\\t{\\n\\t\\t\\twidth = w;\\n\\t\\t}\\n\\t\\tvoid setHeight(int h)\\n\\t\\t{\\n\\t\\t\\theight = h;\\n\\t\\t}\\n\\tprotected:\\n\\t\\tint width;\\n\\t\\tint height;\\n\\nclass Rectangle: public Shape\\n{\\n\\tpublic:\\n\\t\\tint getArea()\\n\\t\\t{\\n\\t\\t\\treturn(width*height);\\n\\t\\t}\\n};\\nint main(void)\\n{\\n\\tRectangle Rect;\\n\\tRect.setWidth(5);\\n\\tRect.setHeight(7);\\n\\tcout<<\"Total area: \"<< Rect.getArea() << endl;\\n\\treturn 0;\\n}",
            "OPT_A" : "Total area: 35",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 17 ,
            "Q_TEXT" : "Multiple Inheritance",
            "Q_PRGM" : "#include <iostream.h>\\nusing namespace std;\\nclass Shape \\n{\\n\\tpublic:\\n\\t\\tvoid setWidth(int w)\\n\\t\\t{\\n\\t\\t\\twidth = w;\\n\\t\\t}\\n\\t\\tvoid setHeight(int h)\\n\\t\\t{\\n\\t\\t\\theight = h;\\n\\t\\t}\\n\\tprotected:\\n\\t\\tint width;\\n\\t\\tint height;\\n\\t\\t};\\nclass PaintCost\\n{\\n\\tpublic:\\n\\t\\tint getCost(int area)\\n\\t\\t{\\n\\t\\t\\treturn area * 70;\\n\\t\\t}\\n};\\nclass Rectangle: public Shape, public PaintCost\\n{\\n\\tpublic:\\n\\t\\tint getArea()\\n\\t\\t{\\n\\t\\t\\treturn (width * height);\\n\\t\\t}\\n};\\nint main(void)\\n{\\n\\tRectangle Rect;\\n\\tint area;\\n\\tRect.setWidth(5);\\n\\tRect.setHeight(7);\\n\\tarea = Rect.getArea();\\n\\tcout<<\"Total area: \"<<Rect.getArea()<<endl;\\n\\tcout<<\"Total paint cost: $\"<< Rect.getCost(area)<< endl;\\n\\treturn 0;\\n}",
            "OPT_A" : "Total area: 35\\nTotal paint cost: $2450",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 18 ,
            "Q_TEXT" : "Function Overloading",
            "Q_PRGM" : "#include <iostream.h>\\nusing namespace std;\\nclass printData\\n{\\n\\tpublic:\\n\\t\\tvoid print(int i)\\n\\t\\t{\\n\\t\\t\\tcout <<\"Printing int: \" << i << endl;\\n\\t\\t}\\n\\t\\tvoid print(double  f)\\n\\t\\t{\\n\\t\\t\\tcout <<\"Printing float: \" << f << endl;\\n\\t\\t}\\n\\t\\tvoid print(char* c)\\n\\t\\t{\\n\\t\\t\\tcout<<\"Printing character: \" << c << endl;\\n\\t\\t}\\n};\\nint main(void)\\n{\\n\\tprintData pd;\\n\\tpd.print(5);\\n\\tpd.print(500.263);\\n\\tpd.print(\"Hello C++\");\\n\\treturn 0;\\n\\t}",
            "OPT_A" : "Printing int: 5\\nrinting float: 500.263\\nPrinting character: Hello C++",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 19 ,
            "Q_TEXT" : "Operator Overloading",
            "Q_PRGM" : "#include <iostream.h>\\nusing namespace std;\\nclass Box\\n{\\n\\tpublic:\\n\\t\\tdouble getVolume(void)\\n\\t\\t{\\n\\t\\t\\treturn length * breadth * height;\\n\\t\\t}\\n\\t\\tvoid setLength(double len)\\n\\t\\t{\\n\\t\\t\\tlength = len;\\n\\t\\t}\\n\\t\\tvoid setBreadth(double bre)\\n\\t\\t{\\n\\t\\t\\tbreadth = bre;\\n\\t\\t}\\n\\t\\tvoid setHeight(double hei)\\n\\t\\t{\\n\\t\\t\\theight = hei;\\n\\t\\t}\\n\\t\\t Box operator+(const Box& b)\\n\\t\\t{\\n\\t\\t\\tBox box;\\n\\t\\t\\tbox.length = this->length + b.length;\\n\\t\\t\\tbox.breadth = this->breadth + b.breadth;\\n\\t\\t\\tbox.height = this->height + b.height;\\n\\t\\t\\treturn box;\\n\\t\\t}\\n\\tprivate:\\n\\t\\tdouble length;\\n\\t\\tdouble breadth;\\n\\t\\tdouble height;\\n};\\nint main( )\\n{\\nBox Box1;\\n\\tBox Box2;\\n\\tBox Box3;\\n\\tdouble volume = 0.0;\\n\\tBox1.setLength(6.0);\\n\\tBox1.setBreadth(7.0);\\n\\tBox1.setHeight(5.0);\\n\\tBox2.setLength(12.0);\\n\\tBox2.setBreadth(13.0);\\n\\tBox2.setHeight(10.0);\\n\\tvolume = Box1.getVolume();\\n\\tcout <<\"Volume of Box1 : \" << volume <<endl;\\n\\tvolume = Box2.getVolume();\\n\\tcout << \"Volume of Box2 : \" << volume <<endl;\\n\\tBox3 = Box1 + Box2;\\n\\tvolume = Box3.getVolume();\\n\\tcout <<\"Volume of Box3 : \" << volume <<endl;\\n\\treturn 0;\\n}",
            "OPT_A" : "Volume of Box1 : 210\\nVolume of Box2 : 1560\\nVolume of Box3 : 5400",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 20 ,
            "Q_TEXT" : "Polymorphism",
            "Q_PRGM" : "#include <iostream.h>\\nusing namespace std;\\nclass Shape\\n {\\n\\tprotected:\\n\\t\\tint width, height;\\n\\tpublic:\\n\\t\\tShape( int a=0, int b=0)\\n\\t\\t{\\n\\t\\t\\twidth = a;\\n\\t\\t\\theight = b;\\n\\t\\t}\\n\\t\\tint area()\\n\\t\\t{\\n\\t\\t\\tcout <<\"Parent class area :\" <<endl;\\n\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n};\\nclass Rectangle: public Shape\\n{\\n\\tpublic:\\n\\t\\tRectangle( int a=0, int b=0):Shape(a, b){ }\\n\\t\\tint area ()\\n\\t\\t{\\n\\t\\t\\tcout <<\"Rectangle class area :\" <<endl;\\n\\t\\t\\treturn (width * height);\\n\\t\\t}\\n};\\nclass Triangle: public Shape\\n{\\n\\tpublic:\\n\\t\\tTriangle( int a=0, int b=0):Shape(a, b){  }\\n\\t\\t int area ()\\n\\t\\t{\\n\\t\\t\\tcout<<\"Triangle class area :\" <<endl;\\n\\t\\t\\treturn(width * height / 2); \\n\\t\\t}\\n};\\nint main( )\\n{\\n\\tShape *shape;\\n\\tRectangle rec(10,7);\\n\\tTriangle  tri(10,5);\\n\\tshape = &rec;\\n\\tshape->area();\\n\\tshape = &tri;\\n\\tshape->area();\\n\\treturn 0;\\n}",
            "OPT_A" : "Parent class area\\nParent class area",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          }
        ]
      },
      {
        "LEVEL_ID": 2,
        "LEVEL_NAME": "Theory",
        "LOCK_STATUS": 1,
        "QUESTIONS": [
          {
            "Q_ID" : 1,
            "Q_TEXT" : "Introduction",
            "Q_PRGM" : "C++ (pronounced as cee plus plus, /ˈsiː plʌs plʌs/) is a general-purpose programming language. It has imperative, object-orientedand generic programming features, while also providing facilities for low-level memory manipulation.\\nIt was designed with a bias toward system programming and embedded, resource-constrained and large systems, with performance, efficiency and flexibility of use as its design highlights. C++ has also been found useful in many other contexts, with key strengths being software infrastructure and resource-constrained applications, including desktop applications, servers (e.g. e-commerce,web search or SQL servers), and performance-critical applications (e.g. telephone switches or space probes). C++ is a compiledlanguage, with implementations of it available on many platforms and provided by various organizations, including the FSF, LLVM,Microsoft, Intel and IBM.\\nC++ is standardized by the International Organization for Standardization (ISO), with the latest (and current) standard version ratified and published by ISO in December 2014 as ISO/IEC 14882:2014 (informally known as C++14). The C++ programming language was initially standardized in 1998 as ISO/IEC 14882:1998, which was then amended by the C++03, ISO/IEC 14882:2003, standard. The current C++14 standard supersedes these and C++11, with new features and an enlarged standard library. Before the initial standardization in 1998, C++ was developed by Bjarne Stroustrup at Bell Labs since 1979, as an extension of the C language as he wanted an efficient and flexible language similar to C, which also provided high-level features for program organization.\\nMany other programming languages have been influenced by C++, including C#, Java, and newer versions of C (after 1998).",
            "OPT_A" : "C++ is standardized by the International Organization for Standardization (ISO), with the latest (and current) standard version ratified and published by ISO in December 2014 as ISO/IEC 14882:2014 (informally known as C++14).",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 2,
            "Q_TEXT" : "History",
            "Q_PRGM" : "Bjarne Stroustrup, a Danish computer scientist, began his work on C++'s predecessor \"C with Classes\" in 1979. The motivation for creating a new language originated from Stroustrup's experience in programming for his Ph.D. thesis. Stroustrup found that Simula had features that were very helpful for large software development, but the language was too slow for practical use, while BCPL was fast but too low-level to be suitable for large software development. When Stroustrup started working in AT&T Bell Labs, he had the problem of analyzing the UNIX kernel with respect to distributed computing. Remembering his Ph.D. experience, Stroustrup set out to enhance the Clanguage with Simula-like features. C was chosen because it was general-purpose, fast, portable and widely used. As well as C and Simula's influences, other languages also influenced C++, including ALGOL 68, Ada, CLU and ML.\\nInitially, the class, derived class, strong typing, inlining and default argument features were added to C via Stroustrup's \"C with Classes\" to C compiler, Cpre.\\nIn 1983, it was renamed from C with Classes to C++ (\"++\" being the increment operator in C). New features were added including virtual functions, function name and operator overloading, references, constants, type-safe free-store memory allocation (new/delete), improved type checking, and BCPL style single-line comments with two forward slashes (//), as well as the development of a proper compiler for C++, Cfront.\\nIn 1985, the first edition of The C++ Programming Language was released, which became the definitive reference for the language, as there was not yet an official standard.The first commercial implementation of C++ was released in October of the same year.\\nIn 1989, C++ 2.0 was released, followed by the updated second edition of The C++ Programming Language in 1991. New features in 2.0 included multiple inheritance, abstract classes, static member functions, const member functions, and protected members. In 1990, The Annotated C++ Reference Manual was published. This work became the basis for the future standard. Later feature additions included templates, exceptions, namespaces, new casts, and a boolean type.\\nAfter the 2.0 update, C++ evolved relatively slowly until, in 2011, the C++11 standard was released, adding numerous new features, enlarging the standard library further, and providing more facilities to C++ programmers. After a minor C++14 update, released in December 2014, various new additions are planned for 2017.",
            "OPT_A" : "Initaially C++ was known as C with Classes",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 3,
            "Q_TEXT" : "Etymology",
            "Q_PRGM" : "According to Stroustrup: \"the name signifies the evolutionary nature of the changes from C\". This name is credited to Rick Mascitti (mid-1983) and was first used in December 1983. When Mascitti was questioned informally in 1992 about the naming, he indicated that it was given in a tongue-in-cheek spirit. The name stems from C's \"++\"operator (which increments the value of a variable) and a common naming convention of using \"+\" to indicate an enhanced computer program.\\nDuring C++'s development period, the language had been referred to as \"new C\" and \"C with Classes\" before acquiring its final name.",
            "OPT_A" : "During C++'s development period, the language had been referred to as \"new C\" and \"C with Classes\" before acquiring its final name.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 4,
            "Q_TEXT" : "Philosophy",
            "Q_PRGM" : "Throughout C++'s life, its development and evolution has been informally governed by a set of rules that its evolution should follow:\\n•	It must be driven by actual problems and its features should be useful immediately in real world programs.\\n•	Every feature should be implementable (with a reasonably obvious way to do so).\\n•	Programmers should be free to pick their own programming style, and that style should be fully supported by C++.\\n•	Allowing a useful feature is more important than preventing every possible misuse of C++.\\n•	It should provide facilities for organising programs into well-defined separate parts, and provide facilities for combining separately developed parts.\\n•	No implicit violations of the type system (but allow explicit violations; that is, those explicitly requested by the programmer).\\n•	User-created types need to have the same support and performance as built-in types.\\n•	Unused features should not negatively impact created executables (e.g. in lower performance).\\n•	There should be no language beneath C++ (except assembly language).\\n•	C++ should work alongside other existing programming languages, rather than fostering its own separate and incompatible programming environment.\\n•	If the programmer's intent is unknown, allow the programmer to specify it by providing manual control.",
            "OPT_A" : "User-created types need to have the same support and performance as built-in types.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 5,
            "Q_TEXT" : "Standardization",
            "Q_PRGM" : "C++ is standardized by an ISO working group known as JTC1/SC22/WG21. So far, it published four revisions of the C++ standard and is currently working on the next revision, C++17.\\nIn 1998, the ISO working group standardized C++ for the first time as ISO/IEC 14882:1998, which is informally known asC++98. In 2003, it published a new version of the C++ standard called ISO/IEC 14882:2003, which fixed problems identified in C++98.\\nThe next major revision of the standard was informally referred to as \"C++0x\", but it was not released until 2011. C++11(14882:2011) included many additions to both the core language and the standard library.\\nIn 2014, C++14 (also known as C++1y) was released as a small extension to C++11, featuring mainly bug fixes and small improvements. The Draft International Standard ballot procedures completed in mid-August 2014.\\nAfter C++14, a major revision, informally known as C++17 or C++1z, is planned for 2017.\\nAs part of the standardization process, ISO also publishes technical reports and specifications:\\n•	ISO/IEC TR 18015:2006 on the use of C++ in embedded systems and on performance implications of C++ language and library features,\\n•	ISO/IEC TR 19768:2007 (also known as the C++ Technical Report 1) on library extensions mostly integrated into C++11,\\n•	ISO/IEC TR 29124:2010 on special mathematical functions,\\n•	ISO/IEC TR 24733:2011 on decimal floating point arithmetic,\\n•	ISO/IEC TS 18822:2015 on the standard filesystem library,\\n•	ISO/IEC TS 19570:2015 on parallel versions of the standard library algorithms,\\n•	ISO/IEC TS 19841:2015 on software transactional memory,\\n•	ISO/IEC TS 19568:2015 on a new set of library extensions, some of which are already integrated into C++17,\\n•	ISO/IEC TS 19217:2015 on the C++ Concepts.",
            "OPT_A" : "More technical specifications are in development and pending approval, including concurrency library extensions, a networking standard library, ranges, and modules.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 6,
            "Q_TEXT" : "Language",
            "Q_PRGM" : "The C++ language has two main components: a direct mapping of hardware features provided primarily by the C subset, and zero-overhead abstractions based on those mappings. Stroustrup describes C++ as \"a light-weight abstraction programming language [designed] for building and using efficient and elegant abstractions\"; and \"offering both hardware access and abstraction is the basis of C++. Doing it efficiently is what distinguishes it from other languages.",
          "OPT_A" : "C++ inherits most of C's syntax",
          "OPT_B" : "A",
          "OPT_C" : "A",
          "OPT_D" : "A",
          "ANSWER" : 1

          },
          {
            "Q_ID" : 7,
            "Q_TEXT" : "Object storage",
            "Q_PRGM" : "As in C, C++ supports four types of memory management: static storage duration objects, thread storage duration objects, automatic storage duration objects, and dynamic storage duration objects.\\nStatic storage duration objects\\nStatic storage duration objects are created before main() is entered (see exceptions below) and destroyed in reverse order of creation after main() exits. The exact order of creation is not specified by the standard (though there are some rules defined below) to allow implementations some freedom in how to organize their implementation. More formally, objects of this type have a lifespan that \"shall last for the duration of the program\".\\nStatic storage duration objects are initialized in two phases. First, \"static initialization\" is performed, and only after all static initialization is performed, \"dynamic initialization\" is performed. In static initialization, all objects are first initialized with zeros; after that, all objects that have a constant initialization phase are initialized with the constant expression (i.e. variables initialized with a literal or constexpr). Though it is not specified in the standard, the static initialization phase can be completed at compile time and saved in the data partition of the executable. Dynamic initialization involves all object initialization done via a constructor or function call (unless the function is marked with constexpr, in C++11). The dynamic initialization order is defined as the order of declaration within the compilation unit (i.e. the same file). No guarantees are provided about the order of initialization between compilation units.\\nThread storage duration objects\\nVariables of this type are very similar to Static Storage duration objects. The main difference is the creation time is just prior to thread creation and destruction is done after the thread has been joined.\\nAutomatic storage duration objects\\nThe most common variable types in C++ are local variables inside a function or block, and temporary variables. The common feature about automatic variables is that they have a lifetime that is limited to the scope of the variable. They are created and potentially initialized at the point of declaration (see below for details) and destroyed in thereverse order of creation when the scope is left.\\nLocal variables are created as the point of execution passes the declaration point. If the variable has a constructor or initializer this is used to define the initial state of the object. Local variables are destroyed when the local block or function that they are declared in is closed. C++ destructors for local variables are called at the end of the object lifetime, allowing a discipline for automatic resource management termed RAII, which is widely used in C++.\\nMember variables are created when the parent object is created. Array members are initialized from 0 to the last member of the array in order. Member variables are destroyed when the parent object is destroyed in the reverse order of creation. i.e. If the parent is an \"automatic object\" then it will be destroyed when it goes out of scope which triggers the destruction of all its members.\\nTemporary variables are created as the result of expression evaluation and are destroyed when the statement containing the expression has been fully evaluated (usually at the; at the end of a statement).\\nDynamic storage duration objects\\nThese objects have a dynamic lifespan and are created with new call and destroyed with an explicit call to delete.",
            "OPT_A" : "Though it is not specified in the standard, the static initialization phase can be completed at compile time and saved in the data partition of the executable. Dynamic initialization involves all object initialization done via a constructor or function call",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 8,
            "Q_TEXT" : "Templates",
            "Q_PRGM" : "C++ templates enable generic programming. C++ supports function, class, alias and variable templates. Templates may be parameterized by types, compile-time constants, and other templates. Templates are implemented by instantiation at compile-time. To instantiate a template, compilers substitute specific arguments for a template's parameters to generate a concrete function or class instance. Some substitutions are not possible; these are eliminated by an overload resolution policy described by the phrase \"Substitution failure is not an error\" (SFINAE). Templates are a powerful tool that can be used for generic programming, template metaprogramming, and code optimization, but this power implies a cost. Template use may increase code size, because each template instantiation produces a copy of the template code: one for each set of template arguments, however, this is the same or smaller amount of code that would be generated if the code was written by hand. This is in contrast to run-time generics seen in other languages (e.g., Java) where at compile-time the type is erased and a single template body is preserved.\\nTemplates are different from macros: while both of these compile-time language features enable conditional compilation, templates are not restricted to lexical substitution. Templates are aware of the semantics and type system of their companion language, as well as all compile-time type definitions, and can perform high-level operations including programmatic flow control based on evaluation of strictly type-checked parameters. Macros are capable of conditional control over compilation based on predetermined criteria, but cannot instantiate new types, recurse, or perform type evaluation and in effect are limited to pre-compilation text-substitution and text-inclusion/exclusion. In other words, macros can control compilation flow based on pre-defined symbols but cannot, unlike templates, independently instantiate new symbols. Templates are a tool for staticpolymorphism (see below) and generic programming.\\nIn addition, templates are a compile time mechanism in C++ that is Turing-complete, meaning that any computation expressible by a computer program can be computed, in some form, by a template metaprogram prior to runtime.\\nIn summary, a template is a compile-time parameterized function or class written without knowledge of the specific arguments used to instantiate it. After instantiation, the resulting code is equivalent to code written specifically for the passed arguments. In this manner, templates provide a way to decouple generic, broadly applicable aspects of functions and classes (encoded in templates) from specific aspects (encoded in template parameters) without sacrificing performance due to abstraction.",
            "OPT_A" : "Macros are capable of conditional control over compilation based on predetermined criteria, but cannot instantiate new types",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 9,
            "Q_TEXT" : "Objects",
            "Q_PRGM" : "C++ introduces object-oriented programming (OOP) features to C. It offers classes, which provide the four features commonly present in OOP (and some non-OOP) languages:abstraction, encapsulation, inheritance, and polymorphism. One distinguishing feature of C++ classes compared to classes in other programming languages is support for deterministic destructors, which in turn provide support for the Resource Acquisition is Initialization (RAII) concept.",
            "OPT_A" : "Classes are just the templates , memory is allocated to the objects",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 10,
            "Q_TEXT" : "Encapsulation",
            "Q_PRGM" : "Encapsulation is the hiding of information to ensure that data structures and operators are used as intended and to make the usage model more obvious to the developer. C++ provides the ability to define classes and functions as its primary encapsulation mechanisms. Within a class, members can be declared as either public, protected, or private to explicitly enforce encapsulation. A public member of the class is accessible to any function. A private member is accessible only to functions that are members of that class and to functions and classes explicitly granted access permission by the class (\"friends\"). A protected member is accessible to members of classes that inherit from the class in addition to the class itself and any friends.\\nThe OO principle is that all of the functions (and only the functions) that access the internal representation of a type should be encapsulated within the type definition. C++ supports this (via member functions and friend functions), but does not enforce it: the programmer can declare parts or all of the representation of a type to be public, and is allowed to make public entities that are not part of the representation of the type. Therefore, C++ supports not just OO programming, but other weaker decomposition paradigms, like modular programming.\\nIt is generally considered good practice to make all data private or protected, and to make public only those functions that are part of a minimal interface for users of the class. This can hide the details of data implementation, allowing the designer to later fundamentally change the implementation without changing the interface in any way.",
            "OPT_A" : " A private member is accessible only to functions that are members of that class and to functions and classes explicitly granted access permission by the class (\"friends\").",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 11,
            "Q_TEXT" : "Inheritance",
            "Q_PRGM" : "Inheritance allows one data type to acquire properties of other data types. Inheritance from a base class may be declared as public, protected, or private. This access specifier determines whether unrelated and derived classes can access the inherited public and protected members of the base class. Only public inheritance corresponds to what is usually meant by \"inheritance\". The other two forms are much less frequently used. If the access specifier is omitted, a \"class\" inherits privately, while a \"struct\" inherits publicly. Base classes may be declared as virtual; this is called virtual inheritance. Virtual inheritance ensures that only one instance of a base class exists in the inheritance graph, avoiding some of the ambiguity problems of multiple inheritance.\\nMultiple inheritance is a C++ feature not found in most other languages, allowing a class to be derived from more than one base class; this allows for more elaborate inheritance relationships. For example, a \"Flying Cat\" class can inherit from both \"Cat\" and \"Flying Mammal\". Some other languages, such as C# or Java, accomplish something similar (although more limited) by allowing inheritance of multiple interfaces while restricting the number of base classes to one (interfaces, unlike classes, provide only declarations of member functions, no implementation or member data). An interface as in C# and Java can be defined in C++ as a class containing only pure virtual functions, often known as anabstract base class or \"ABC\". The member functions of such an abstract base class are normally explicitly defined in the derived class, not inherited implicitly. C++ virtual inheritance exhibits an ambiguity resolution feature called dominance.",
            "OPT_A" : " Multiple inheritance is a C++ feature not found in most other languages, allowing a class to be derived from more than one base class.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 12,
            "Q_TEXT" : "Operators and operator overloading",
            "Q_PRGM" : "C++ provides more than 35 operators, covering basic arithmetic, bit manipulation, indirection, comparisons, logical operations and others. Almost all operators can be overloaded for user-defined types, with a few notable exceptions such as member access (. and .*) as well as the conditional operator. The rich set of overloadable operators is central to making user-defined types in C++ seem like built-in types.\\nOverloadable operators are also an essential part of many advanced C++ programming techniques, such as smart pointers. Overloading an operator does not change the precedence of calculations involving the operator, nor does it change the number of operands that the operator uses (any operand may however be ignored by the operator, though it will be evaluated prior to execution). Overloaded \"&&\" and \"||\" operators lose their short-circuit evaluation property.",
            "OPT_A" : "Operators that cannot be overloaded\\nScope resolution operator	::\\nConditional operator	?:\\ndot operator	.\\nMember selection operator	.*\\n\"sizeof\" operator	sizeof\\n\"0typeid\" operator	typeid",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 13,
            "Q_TEXT" : "Polymorphism",
            "Q_PRGM" : "Polymorphism enables one common interface for many implementations, and for objects to act differently under different circumstances.\\nC++ supports several kinds of static (compile-time) and dynamic (run-time) polymorphisms, supported by the language features described above. Compile-time polymorphism does not allow for certain run-time decisions, while run-time polymorphism typically incurs a performance penalty.\\nStatic polymorphism\\nFunction overloading allows programs to declare multiple functions having the same name but with different arguments (i.e. ad hoc polymorphism). The functions are distinguished by the number or types of their formal parameters. Thus, the same function name can refer to different functions depending on the context in which it is used. The type returned by the function is not used to distinguish overloaded functions and would result in a compile-time error message.\\nWhen declaring a function, a programmer can specify for one or more parameters a default value. Doing so allows the parameters with defaults to optionally be omitted when the function is called, in which case the default arguments will be used. When a function is called with fewer arguments than there are declared parameters, explicit arguments are matched to parameters in left-to-right order, with any unmatched parameters at the end of the parameter list being assigned their default arguments. In many cases, specifying default arguments in a single function declaration is preferable to providing overloaded function definitions with different numbers of parameters.\\nTemplates in C++ provide a sophisticated mechanism for writing generic, polymorphic code (i.e. parametric polymorphism). In particular, through the Curiously Recurring Template Pattern, it's possible to implement a form of static polymorphism that closely mimics the syntax for overriding virtual functions. Because C++ templates are type-aware and Turing-complete, they can also be used to let the compiler resolve recursive conditionals and generate substantial programs through template metaprogramming. Contrary to some opinion, template code will not generate a bulk code after compilation with the proper compiler settings.\\nDynamic polymorphism\\nVariable pointers (and references) to a base class type in C++ can refer to objects of any derived classes of that type in addition to objects exactly matching the variable type. This allows arrays and other kinds of containers to hold pointers to objects of differing types. Because assignment of values to variables usually occurs at run-time, this is necessarily a run-time phenomenon.\\nC++ also provides a dynamic_cast operator, which allows the program to safely attempt conversion of an object into an object of a more specific object type (as opposed to conversion to a more general type, which is always allowed). This feature relies on run-time type information (RTTI). Objects known to be of a certain specific type can also be cast to that type with static_cast, a purely compile-time construct that has no runtime overhead and does not require RTTI.\\nVirtual member functions\\nOrdinarily, when a function in a derived class overrides a function in a base class, the function to call is determined by the type of the object. A given function is overridden when there exists no difference in the number or type of parameters between two or more definitions of that function. Hence, at compile time, it may not be possible to determine the type of the object and therefore the correct function to call, given only a base class pointer; the decision is therefore put off until runtime. This is called dynamic dispatch. Virtual member functions or methods allow the most specific implementation of the function to be called, according to the actual run-time type of the object. In C++ implementations, this is commonly done using virtual function tables. If the object type is known, this may be bypassed by prepending a fully qualified class name before the function call, but in general calls to virtual functions are resolved at run time.\\nIn addition to standard member functions, operator overloads and destructors can be virtual. As a rule of thumb, if any function in the class is virtual, the destructor should be as well. As the type of an object at its creation is known at compile time, constructors, and by extension copy constructors, cannot be virtual. Nonetheless a situation may arise where a copy of an object needs to be created when a pointer to a derived object is passed as a pointer to a base object. In such a case, a common solution is to create aclone() (or similar) virtual function that creates and returns a copy of the derived class when called.\\nA member function can also be made \"pure virtual\" by appending it with = 0 after the closing parenthesis and before the semicolon. A class containing a pure virtual function is called an abstract data type. Objects cannot be created from abstract data types; they can only be derived from. Any derived class inherits the virtual function as pure and must provide a non-pure definition of it (and all other pure virtual functions) before objects of the derived class can be created. A program that attempts to create an object of a class with a pure virtual member function or inherited pure virtual member function is ill-formed.",
            "OPT_A" : "C++ also provides a dynamic_cast operator, which allows the program to safely attempt conversion of an object into an object of a more specific object type",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 14,
            "Q_TEXT" : "Lambda expressions",
            "Q_PRGM" : "C++ provides support for anonymous functions, which are also known as lambda expressions and have the following form:\\n[capture](parameters) -> return_type { function_body }\\nThe [capture] list supports the definition of closures. Such lambda expressions are defined in the standard as syntactic sugar for an unnamed function object. An example lambda function may be defined as follows:\\n[](int x, int y) -> int { return x + y; }",
            "OPT_A" : "The [capture] list supports the definition of closures. ",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 15,
            "Q_TEXT" : "Exception handling",
            "Q_PRGM" : "Exception handling is used to communicate the existence of a runtime problem or error from where it was detected to where the issue can be handled. It permits this to be done in a uniform manner and separately from the main code, while detecting all errors. Should an error occur, an exception is thrown (raised), which is then caught by the nearest suitable exception handler. The exception causes the current scope to be exited, and also each outer scope (propagation) until a suitable handler is found, calling in turn the destructors of any objects in these exited scopes. At the same time, an exception is presented as an object carrying the data about the detected problem.\\nThe exception-causing code is placed inside a try block. The exceptions are handled in separate catch blocks (the handlers)",
            "OPT_A" : " Each try block can have multiple exception handlers",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          }
        ]
      },
      {
        "LEVEL_ID": 3,
        "LEVEL_NAME": "Miscellaneous",
        "LOCK_STATUS": 1,
        "QUESTIONS": [
          {
            "Q_ID": 1,
            "Q_TEXT": " How many characters are specified in the ASCII scheme?",
            "Q_PRGM": "",
            "OPT_A": "64",
            "OPT_B": "128",
            "OPT_C": "256",
            "OPT_D": "none of the mentioned",
            "ANSWER": 2
          },
          {
            "Q_ID": 2,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "#include <iostream>\\nusing namespace std;\\nint main()\\n{\\n\\tchar c = 74;\\n\\tcout << c;\\n\\treturn 0;\\n\\t}",
            "OPT_A": "A",
            "OPT_B": "N",
            "OPT_C": "J",
            "OPT_D": "I",
            "ANSWER": 3
          },
          {
            "Q_ID": 3,
            "Q_TEXT": "The size of an object or a type can be determined using which operator?",
            "Q_PRGM": "",
            "OPT_A": "malloc",
            "OPT_B": "sizeof",
            "OPT_C": "alloc",
            "OPT_D": "calloc",
            "ANSWER": 2
          },
          {
            "Q_ID": 4,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "include <stdio.h>\\nint main()\\n\\t{\\nchar a = \"012\";\\n\\tprintf(\"%d\", a);\\n\\treturn 0;\\n\\t}",
            "OPT_A": "Compiler error",
            "OPT_B": "12",
            "OPT_C": "10",
            "OPT_D": "Empty",
            "ANSWER": 3
          },
          {
            "Q_ID": 5,
            "Q_TEXT": "What does a escape code represent?",
            "Q_PRGM": "",
            "OPT_A": "alert",
            "OPT_B": "backslash",
            "OPT_C": "tab",
            "OPT_D": "form feed",
            "ANSWER": 1
          },
          {
            "Q_ID": 6,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "#include <iostream>\\nusing namespace std;\\nint main()\\n\\t{\\n\\tint num = 0x20 + 020 +20;\\n\\tcout << sizeof(num)<<'\n';\\n\\treturn 0;\\n\\t}",
            "OPT_A": "2",
            "OPT_B": "4",
            "OPT_C": "Depends on compiler.",
            "OPT_D": "garbage",
            "ANSWER": 3
          },
          {
            "Q_ID": 7,
            "Q_TEXT": "Which operator is having the highest precedence?",
            "Q_PRGM": "",
            "OPT_A": "postfix",
            "OPT_B": "unary",
            "OPT_C": "shift",
            "OPT_D": "equality",
            "ANSWER": 1
          },
          {
            "Q_ID": 8,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "#include <iostream>\\nusing namespace std;\\nint main()\\n{\\n\\tint a;\\n\\ta = 5 + 3 * 5;\\n\\tcout << a;\\n\\treturn 0;\\n}",
            "OPT_A": "35",
            "OPT_B": "20",
            "OPT_C": "25",
            "OPT_D": "30",
            "ANSWER": 2
          },
          {
            "Q_ID": 9,
            "Q_TEXT": "Which of the following is a valid floating point literal?",
            "Q_PRGM": "",
            "OPT_A": "f287.333",
            "OPT_B": "F287.333",
            "OPT_C": "287.e2",
            "OPT_D": "287.3.e2",
            "ANSWER": 3
          },
          {
            "Q_ID": 10,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "#include <iostream>\\nusing namespace std;\\nint main()\\n{\\n\\tfloat num1 = 1.1;\\n\\tdouble num2 = 1.1;\\n\\tif (num1 == num2)\\n\\t\\tcout << \"stanford\";\\n\\telse\\n\\t\\tcout << \"harvard\";\\n\\treturn 0;\\n}",
            "OPT_A": "harvard",
            "OPT_B": "stanford",
            "OPT_C": "compile time error",
            "OPT_D": "runtime error",
            "ANSWER": 1
          },
          {
            "Q_ID": 11,
            "Q_TEXT": "What does the following statement mean?\\nint (*fp)(char*)",
            "Q_PRGM": "",
            "OPT_A": "pointer to a pointer",
            "OPT_B": "pointer to an array of chars",
            "OPT_C": "pointer to function taking a char* argument and returns an int",
            "OPT_D": "function taking a char* argument and returning a pointer to int",
            "ANSWER": 3
          },
          {
            "Q_ID": 12,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "#include <iostream>\\nusing namespace std;\\nint main()\\n{\\n\\tint a = 5, b = 10, c = 15;\\n\\tint *arr[ ] = {&a, &b, &c};\\n\\tcout << arr[1];\\n\\treturn 0;\\n}",
            "OPT_A": "5",
            "OPT_B": "10",
            "OPT_C": "15",
            "OPT_D": "it will return some random number",
            "ANSWER": 4
          },
          {
            "Q_ID": 13,
            "Q_TEXT": "What is the index number of the last element of an array with 9 elements?",
            "Q_PRGM": "",
            "OPT_A": "9",
            "OPT_B": "8",
            "OPT_C": "0",
            "OPT_D": "Programmer-defined",
            "ANSWER": 2
          },
          {
            "Q_ID": 14,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "#include <stdio.h>\\nusing namespace std;\\nint main()\\n{\\n\\tchar str[5] = \"ABC\";\\n\\tcout << str[3];\\n\\tcout << str;\\n\\treturn 0;\\n}",
            "OPT_A": "ABC",
            "OPT_B": "ABCD",
            "OPT_C": "AB",
            "OPT_D": "None of the mentioned",
            "ANSWER": 1
          },
          {
            "Q_ID": 15,
            "Q_TEXT": "In which of the following we cannot overload the function?",
            "Q_PRGM": "",
            "OPT_A": "return function",
            "OPT_B": "caller",
            "OPT_C": "called function",
            "OPT_D": "none of the mentioned",
            "ANSWER": 1
          },
          {
            "Q_ID": 16,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "#include <stdio.h>\\nusing namespace std;\\nint main()\\n{\\n\\yint array[] = {10, 20, 30};\\n\\tcout << -2[array];\\n\\treturn 0;\\n}",
            "OPT_A": "-15",
            "OPT_B": "-30",
            "OPT_C": "compile time error",
            "OPT_D": "garbage value",
            "ANSWER": 2
          },
          {
            "Q_ID": 17,
            "Q_TEXT": "Pick out the correct statement.",
            "Q_PRGM": "",
            "OPT_A": "A friend function may be a member of another class.",
            "OPT_B": " A friend function may not be a member of another class.",
            "OPT_C": " A friend function may or may not be a member of another class.",
            "OPT_D": " None of the mentioned",
            "ANSWER": 3
          },
          {
            "Q_ID": 18,
            "Q_TEXT": "What is the new value of x?",
            "Q_PRGM": "#include <iostream>\\nusing namespace std;\\nvoid fun(int &x)\\n{\\n\\tx = 20;\\n}\\nint main()\\n{\\n\\tint x = 10;\\n\\tfun(x);\\n\\tcout << \"New value of x is \" << x;\\n\\treturn 0;\\n}",
            "OPT_A": "10",
            "OPT_B": "20",
            "OPT_C": "15",
            "OPT_D": " none of the mentioned",
            "ANSWER": 2
          },
          {
            "Q_ID": 19,
            "Q_TEXT": "How many ways of passing a parameter are there in c++?",
            "Q_PRGM": "",
            "OPT_A": "1",
            "OPT_B": "2",
            "OPT_C": "3",
            "OPT_D": "4",
            "ANSWER": 3
          },
          {
            "Q_ID": 20,
            "Q_TEXT": " What is the output of this program?",
            "Q_PRGM": "#include <iostream>\\nusing namespace std;\\nint max(int a, int b )\\n{\\n\\treturn ( a > b ? a : b);\\n}\\nint main()\\n{\\n\\tint i = 5;\\n\\tint j = 7;\\n\\tcout << max(i, j );\\n\\treturn 0;\\n}",
            "OPT_A": "5",
            "OPT_B": "7",
            "OPT_C": "either a or b",
            "OPT_D": "none of the mentioned",
            "ANSWER": 2
          },
          {
            "Q_ID": 21,
            "Q_TEXT": " What are the advantages of passing arguments by reference?",
            "Q_PRGM": "",
            "OPT_A": " Changes to parameter values within the function also affect the original arguments.",
            "OPT_B": "There is need to copy parameter values (i.e. less memory used)",
            "OPT_C": "There is no need to call constructors for parameters (i.e. faster)",
            "OPT_D": "All of the mentioned",
            "ANSWER": 4
          },
          {
            "Q_ID": 22,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "#include <iostream>\\nusing namespace std;\\nint Add(int X, int Y, int Z)\\n{\\n\\treturn X + Y;\\n}\\ndouble Add(double X, double Y, double Z)\\n{\\n\\treturn X + Y;\\n}\\nint main()\\n{\\n\\tcout << Add(5, 6);\\n\\tcout << Add(5.5, 6.6);\\n\\treturn 0;\\n}",
            "OPT_A": "11 12.1",
            "OPT_B": "12.1 11",
            "OPT_C": "11 12",
            "OPT_D": "compile time error",
            "ANSWER": 4
          },
          {
            "Q_ID": 23,
            "Q_TEXT": "Pick out the correct statement.",
            "Q_PRGM": "",
            "OPT_A": "Increment operator ++ adds 1 to its operand",
            "OPT_B": "Increment operator ++ adds 2 to its operand",
            "OPT_C": "Decrement operator ++ subtracts 1 to its operand",
            "OPT_D": "None of the mentioned",
            "ANSWER": 1
          },
          {
            "Q_ID": 24,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "#include <stdio.h>\\n using namespace std;\\nint main()\\n{\\n\\tint a = 21;\\n\\tint c ;\\n\\tc = a++;\\n\\tcout << c;\\n\\treturn 0;\\n}",
            "OPT_A": "21",
            "OPT_B": "22",
            "OPT_C": "23",
            "OPT_D": "20",
            "ANSWER": 1
          },
          {
            "Q_ID": 25,
            "Q_TEXT": "Where does the object is created?",
            "Q_PRGM": "",
            "OPT_A": "class",
            "OPT_B": "constructor",
            "OPT_C": "destructor",
            "OPT_D": "attributes",
            "ANSWER": 1
          },
          {
            "Q_ID": 26,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "#include <iostream>\\nusing namespace std;\\nvoid fun(int x, int y)\\n{\\n\\tx = 20;\\n\\ty = 10;\\n}\\nint main()\\n{\\n\\tint x = 10;\\n\\tfun(x, x);\\n\\tcout << x;\\n\\treturn 0;\\n}",
            "OPT_A": "10",
            "OPT_B": "20",
            "OPT_C": "compile time error",
            "OPT_D": "none of the mentioned",
            "ANSWER": 1
          },
          {
            "Q_ID": 27,
            "Q_TEXT": "Which of the following can derived class inherit?",
            "Q_PRGM": "",
            "OPT_A": "members",
            "OPT_B": "functions",
            "OPT_C": "both a & b",
            "OPT_D": "None of the mentioned",
            "ANSWER": 3
          },
          {
            "Q_ID": 28,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "#include <iostream>\\nusing namespace std;\\nstruct a\\n{\\n\\tint count;\\n};\\nstruct b\\n{\\n\\tint* value;\\n};\\nstruct c : public a, public b\\n{\\n};\\nint main()\\n{\\n\\tc* p = new c;\\n\\tp->value = 0;\\n\\tcout << \"Inherited\";\\n\\treturn 0;\\n}",
            "OPT_A": "Inherited",
            "OPT_B": "Error",
            "OPT_C": "Runtime error",
            "OPT_D": "None of the mentioned",
            "ANSWER": 1
          },
          {
            "Q_ID": 29,
            "Q_TEXT": "Which design patterns benefit from the multiple inheritance?",
            "Q_PRGM": "",
            "OPT_A": "Adapter and observer pattern",
            "OPT_B": "Code pattern",
            "OPT_C": "Glue pattern",
            "OPT_D": "None of the mentioned",
            "ANSWER": 1
          },
          {
            "Q_ID": 30,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "#include <iostream>\\nusing namespace std;\\nclass Cat\\n{\\n\\tpublic:\\n\\tint age;\\n\\tint weight;\\n};\\nint main()\\n{\\n\\tCat f;\\n\\tf.age = 56;\\n\\tcout << \"Gates is \" ;\\n\\tcout << f.age << \" years old.\n\";\\n}",
            "OPT_A": "Gates is",
            "OPT_B": "Gates is 56 years old",
            "OPT_C": "Error",
            "OPT_D": "None of the mentioned",
            "ANSWER": 2
          },
          {
            "Q_ID": 31,
            "Q_TEXT": "What is the default access level to a block of data?",
            "Q_PRGM": "",
            "OPT_A": "Public",
            "OPT_B": "Protected",
            "OPT_C": "Private",
            "OPT_D": "None of the mentioned",
            "ANSWER": 3
          },
          {
            "Q_ID": 32,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "#include <iostream>\\n#include <typeinfo>\\nusing namespace std;\\nint main ()\\n{\\n\\tint * a;\\n\\tint b;\\n\\ta = 0; b = 0;\\n\\tif (typeid(a) != typeid(b))\\n\\t{\\n\\t\\tcout << typeid(a).name();\\n\\t\\tcout << typeid(b).name();\\n\\t}\\n\\treturn 0;\\n}",
            "OPT_A": "Pi",
            "OPT_B": "i",
            "OPT_C": "Both a & b",
            "OPT_D": "f",
            "ANSWER": 3
          },
          {
            "Q_ID": 33,
            "Q_TEXT": "Which character is used to terminate the string?",
            "Q_PRGM": "",
            "OPT_A": "$",
            "OPT_B": "Null",
            "OPT_C": "Empty",
            "OPT_D": "None of the mentioned",
            "ANSWER": 2
          },
          {
            "Q_ID": 34,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "#include <iostream>\\n#include <string>\\nusing namespace std;\\nint main ()\\n{\\n\\tstring str;\\n\\tstring str2=\"Steve jobs\";\\n\\tstring str3=\"He foundedapple\";\\n\\tstr.append(str2);\\n\\tstr.append(str3, 6, 3);\\n\\tstr.append(str3.begin() + 6,str3.end());\\n\\tstr.append<int>(5, 0x2E);\\n\\tcout << str << '\n';\\n\\treturn 0;\\n}",
            "OPT_A": "Steve jobs",
            "OPT_B": "He founded apple",
            "OPT_C": "Steve",
            "OPT_D": "None of the mentioned",
            "ANSWER": 1
          },
          {
            "Q_ID": 35,
            "Q_TEXT": "What will happen if a string is empty?",
            "Q_PRGM": "",
            "OPT_A": "It can’t be created",
            "OPT_B": "Raises an error",
            "OPT_C": "It can be used",
            "OPT_D": "None of the mentioned",
            "ANSWER": 3
          },
          {
            "Q_ID": 36,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "#include <iostream>\\n#include <string>\\nusing namespace std;\\nint main ()\\n{\\n\\tstring str (\"Steve jobs\");\\n\\tcout << str.length();\\n\\treturn 0;\\n}",
            "OPT_A": "8",
            "OPT_B": "10",
            "OPT_C": "12",
            "OPT_D": "9",
            "ANSWER": 2
          },
          {
            "Q_ID": 37,
            "Q_TEXT": "Pick out the correct objects about the instantiation of output stream.",
            "Q_PRGM": "",
            "OPT_A": "cout",
            "OPT_B": "cerr",
            "OPT_C": "clog",
            "OPT_D": "All of the mentioned",
            "ANSWER": 4
          },
          {
            "Q_ID": 38,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": " #include <iostream>\\nusing namespace std;\\nint main ()\\n{\\n\\tchar str[] = \"Steve jobs\";\\n\\tint val = 65;\\n\\tchar ch = 'A';\\n\\tcout.width (5);\\t\\tcout << right;\\n\\tcout << val << endl;\\n\\treturn 0;\\n}",
            "OPT_A": "Steve jobs",
            "OPT_B": "A",
            "OPT_C": "5",
            "OPT_D": "65",
            "ANSWER": 4
          },
          {
            "Q_ID": 39,
            "Q_TEXT": "What must be specified when we construct an object of class ostream?",
            "Q_PRGM": "",
            "OPT_A": "stream",
            "OPT_B": "streambuf",
            "OPT_C": "memory",
            "OPT_D": "None of the mentioned",
            "ANSWER": 2
          },
          {
            "Q_ID": 40,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "#include <iostream>\\n#include <locale>\\nusing namespace std;\\nint main()\\n{\\n\\tlocale mylocale(\"\");\\n\\tcout.imbue( mylocale );\\n\\tcout << (double) 3.14159 << endl;\\n\\treturn 0;\\n}",
            "OPT_A": "3.14",
            "OPT_B": "3.14159",
            "OPT_C": "Error",
            "OPT_D": "None of the mentioned",
            "ANSWER": 2
          },
          {
            "Q_ID": 41,
            "Q_TEXT": "The constants are also called as",
            "Q_PRGM": "",
            "OPT_A": "const",
            "OPT_B": "preprocessor",
            "OPT_C": "literals",
            "OPT_D": "none of the mentioned",
            "ANSWER": 3
          },
          {
            "Q_ID": 42,
            "Q_TEXT": "How the constants are declared?",
            "Q_PRGM": "",
            "OPT_A": "const keyword",
            "OPT_B": "#define preprocessor",
            "OPT_C": "both a and b",
            "OPT_D": "None of the mentioned",
            "ANSWER": 3
          },
          {
            "Q_ID": 43,
            "Q_TEXT": "Which of the following statement is not true about preprocessor directives?",
            "Q_PRGM": "",
            "OPT_A": "These are lines read and processed by the preprocessor",
            "OPT_B": "They do not produce any code by themselves",
            "OPT_C": "These must be written on their own line",
            "OPT_D": "They end with a semicolon",
            "ANSWER": 4
          },
          {
            "Q_ID": 44,
            "Q_TEXT": "How to declare a wide character in string literal?",
            "Q_PRGM": "",
            "OPT_A": "L prefix",
            "OPT_B": "l prefix",
            "OPT_C": "W prefix",
            "OPT_D": "none of the mentioned",
            "ANSWER": 1
          },
          {
            "Q_ID": 45,
            "Q_TEXT": "When does the void pointer can be dereferenced?",
            "Q_PRGM": "",
            "OPT_A": "when it doesn’t point to any value",
            "OPT_B": "when it cast to another type of object",
            "OPT_C": "using delete keyword",
            "OPT_D": "none of the mentioned",
            "ANSWER": 2
          },
          {
            "Q_ID": 46,
            "Q_TEXT": "A void pointer cannot point to which of these?",
            "Q_PRGM": "",
            "OPT_A": "methods in c++",
            "OPT_B": "class member in c++",
            "OPT_C": "all of the mentioned",
            "OPT_D": "none of the mentioned",
            "ANSWER": 4
          },
          {
            "Q_ID": 47,
            "Q_TEXT": "What we can’t do on a void pointer?",
            "Q_PRGM": "",
            "OPT_A": "pointer arithemetic",
            "OPT_B": "pointer functions",
            "OPT_C": "both of the mentioned",
            "OPT_D": "none of the mentioned",
            "ANSWER": 1
          },
          {
            "Q_ID": 48,
            "Q_TEXT": "It is guaranteed that a ____ has atleast 8bits and a ____ has atleast 16 bits.",
            "Q_PRGM": "",
            "OPT_A": "int, float",
            "OPT_B": "char, int",
            "OPT_C": "bool, char",
            "OPT_D": "char, short",
            "ANSWER": 4
          },
          {
            "Q_ID": 49,
            "Q_TEXT": "Size of C++ objects are expressed in terms of multiples of the size of a ____ and the size of a char is____.",
            "Q_PRGM": "",
            "OPT_A": "char, 1",
            "OPT_B": "int, 1",
            "OPT_C": "float, 8",
            "OPT_D": "char, 4",
            "ANSWER": 1
          },
          {
            "Q_ID": 50,
            "Q_TEXT": "Identify the incorrect statement",
            "Q_PRGM": "",
            "OPT_A": "reference is the alternate name of the object",
            "OPT_B": "A reference value once defined can be reassigned",
            "OPT_C": "A reference value once defined cannot be reassigned",
            "OPT_D": "none of the mentioned",
            "ANSWER": 2
          }
        ]
      }
    ]
  },
  {
    "CAT_ID": 3,
    "CAT_NAME": "JAVA",
    "LEVELS": [
      {
        "LEVEL_ID": 1,
        "LEVEL_NAME": "Practical",
        "LOCK_STATUS": 1,
        "QUESTIONS": [
          {
            "Q_ID" : 1 ,
            "Q_TEXT" : "To Print Integers",
            "Q_PRGM" : "class ForLoop\\n{\\npublic static void main(String[] args)\\n{\\n\\tint c;\\n\\tfor (c = 1; c <= 10; c++)\\n\\t{\\n\\t\\tSystem.out.println(c);\\n\\t}\\n\\t}\\n}",
            "OPT_A" : "1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n10",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 2 ,
            "Q_TEXT" : "Pattern 1",
            "Q_PRGM" : "class Stars\\n{\\n\\tpublic static void main(String[] args) \\n\\t{\\n\\tint row, numberOfStars;\\n\\t\\tfor (row = 1; row <= 10; row++)\\n\\t\\t{\\n\\t\\t\\tfor(numberOfStars = 1; numberOfStars <= row;   numberOfStars++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSystem.out.print(\"*\");\\n\\t\\t\\t}\\n\\t\\t\\tSystem.out.println();\\n\\t\\t}\\n\\t}\\n}",
            "OPT_A" : "*\\n**\\n***\\n****\\n*****\\n",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 3 ,
            "Q_TEXT" : "Accept the input till zero is entered",
            "Q_PRGM" : "import java.util.Scanner;\\nclass WhileLoop\\n{\\n\\tpublic static void main(String[] args)\\n{\\n\\tint n;\\n\\tScanner input = new Scanner(System.in);\\n\\tSystem.out.println(\"Input an integer\");\\n\\twhile ((n = input.nextInt()) != 0)\\n\\t{\\n\\t\\tSystem.out.println(\"You entered \" + n);\\n\\t\\tSystem.out.println(\"Input an integer\");\\n\\t\\t}\\n\\tSystem.out.println(\"Out of loop\");\\n\\t}\\n}",
            "OPT_A" : "Input an integer\\n200\\nYou Entered 200\\nInput an integer\\n-22\\nYou Entered -22\\nInput an integer\\n0\\nOut of Loop",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 4 ,
            "Q_TEXT" : "Print Alphabets",
            "Q_PRGM" : "class Alphabets\\n{\\n\\tpublic static void main(String args[])\\n\\t{\\n\\t\\tchar ch;\\n\\t\\tfor( ch = 'a' ; ch <= 'z' ; ch++ )\\n\\t\\t\\tSystem.out.print(ch);\\n\\t}\\n}",
            "OPT_A" : "abcdefghijklmnopqrstuvwxyz",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 5 ,
            "Q_TEXT" : "Multiplication Table" ,
            "Q_PRGM" : "import java.util.Scanner;\\nclass MultiplicationTable\\n{\\n\\tpublic static void main(String args[])\\n\\t{\\n\\t\\tint n, c;\\n\\t\\tSystem.out.println(\"Enter an integer to print it's multiplication table\");\\n\\t\\tScanner in = new Scanner(System.in);\\n\\t\\tn = in.nextInt();\\n\\t\\tSystem.out.println(\"Multiplication table of \"+n+\" is :-\");\\n\\t\\tfor (c=1;c<=10;c++)\\n\\t\\tSystem.out.println(n+\"*\"+c+\" = \"+(n*c));\\n\\t}\\n}",
            "OPT_A" : "Enter an integer to print it's multiplication table\\n8\\nMultiplication table of 8 is :-\\n8*1=8\\n8*2=16\\n8*3=24\\n8*4=32\\n8*5=40\\n8*6=48\\n8*7=56\\n8*8=64\\n8*9=72\\n8*10=80\\n",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 6 ,
            "Q_TEXT" : "To take input from user using Scanner function",
            "Q_PRGM" : "import java.util.Scanner;\\nclass GetInputFromUser\\n{\\n\\tpublic static void main(String args[])\\n\\t{\\n\\tint a;\\n\\tfloat b;\\n\\tString s;\\n\\tScanner in = new Scanner(System.in);\\n\\tSystem.out.println(\"Enter a string\");\\n\\ts = in.nextLine();\\n\\tSystem.out.println(\"You entered string \"+s);\\n\\tSystem.out.println(\"Enter an integer\");\\n\\ta = in.nextInt();\\n\\tSystem.out.println(\"You entered integer\"+a);\\n\\tSystem.out.println(\"Enter a float\");\\n\\tb = in.nextFloat();\\n\\tSystem.out.println(\"You entered float\"+b);\\n\\t}\\n}",
            "OPT_A" : "Enter a string\\nMy program\\nYou entered string My program.\\nEnter an integer\\n3\\nYou entered integer 3\\nEnter a float\\n2.3\\nYou entered float 2.3\\n",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 7 ,
            "Q_TEXT" : "To add to Big Integer",
            "Q_PRGM" : "import java.util.Scanner;\\nimport java.math.BigInteger;\\nclass AddingLargeNumbers\\n{\\n\\tpublic static void main(String[] args)\\n\\t{\\n\\t\\tString number1, number2;\\n\\t\\tScanner in = new Scanner(System.in);\\n\\t\\tSystem.out.println(\"Enter first large number\");\\n\\t\\tnumber1 = in.nextLine();\\n\\t\\tSystem.out.println(\"Enter second large number\");\\n\\t\\tnumber2 = in.nextLine();\\n\\t\\tBigInteger first  = new BigInteger(number1);\\n\\t\\tBigInteger second = new BigInteger(number2);\\n\\t\\tBigInteger sum;\\n\\t\\tsum = first.add(second);\\n\\t\\tSystem.out.println(\"Result of addition = \" + sum)\\n\\t;}\\n}",
            "OPT_A" : " Enter first large number\\n11111111111111\\nEnter second large number\\n99999999999999\\nResult of addition = 111111111111110\\n",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 8 ,
            "Q_TEXT" : "to convert Farenhiet to Celcius",
            "Q_PRGM" : "import java.util.*;\\nclass FahrenheitToCelsius\\n{\\npublic static void main(String[] args)\\n\\t{\\n\\tfloat temperatue;\\n\\tScanner in = new Scanner(System.in);\\n\\tSystem.out.println(\"Enter temperatue in Fahrenheit\");\\n\\ttemperatue = in.nextInt();\\n\\ttemperatue = ((temperatue - 32)*5)/9;\\n\\tSystem.out.println(\"Temperatue in Celsius = \" + temperatue);\\n\\t}\\n}",
            "OPT_A" : "Enter temperatue in Fahrenheit\\n100\\nTemperatue in Celsius = 37.77778\\n",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 9 ,
            "Q_TEXT" : "Static block",
            "Q_PRGM" : "class StaticBlock \\n{\\n\\tpublic static void main(String[] args)\\n\\t{\\n\\tSystem.out.println(\"Main method is executed.\");\\n\\t}\\n\\tstatic\\n\\t{\\n\\t\\tSystem.out.println(\"Static block is executed before main method.\");\\n\\t}\\n}",
            "OPT_A" : "Static block is executed before main method.\\nMain method is executed.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 10 ,
            "Q_TEXT" : "Static Method",
            "Q_PRGM" : "class Languages\\n{\\n\\tpublic static void main(String[] args)\\n\\t{\\n\\t\\tdisplay();\\n\\t}\\n\\tstatic void display()\\n\\t{\\n\\tSystem.out.println(\"Java is my favorite programming language.\");\\n\\t}\\n}",
            "OPT_A" : "Java is my favorite programming language.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 12 ,
            "Q_TEXT" : "Static method Vs Instance Method ",
            "Q_PRGM" : "class Difference\\n{\\n\\tpublic static void main(String[] args) \\n\\t{\\n\\t\\tdisplay();\\n\\t\\tDifference t = new Difference();\\n\\t\\tt.show(); \\n\\t}static void display()\\n\\t{\\n\\tSystem.out.println(\"Programming is amazing.\");\\n\\t}\\n\\tvoid show(){\\n\\t\\tSystem.out.println(\"Java is awesome.\");\\n\\t}\\n}",
            "OPT_A" : "Programming is amazing.\\nJava is awesome.\\n",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 13 ,
            "Q_TEXT" : "Multiple Classes in one program.",
            "Q_PRGM" : "class Computer\\n{\\n\\tComputer()\\n\\t{\\n\\t\\tSystem.out.println(\"Constructor of Computer class.\");\\n\\t}\\n\\tvoid computer_method()\\n\\t{\\n\\t\\tSystem.out.println(\"Power gone! Shut down your PC soon...\");\\n\\t}\\n\\tpublic static void main(String[] args) \\n\\t{\\n\\t\\tComputer my = new Computer();\\n\\t\\tLaptop your = new Laptop();\\n\\t\\tmy.computer_method();\\n\\t\\tyour.laptop_method();\\n\\t}\\n}\\nclass Laptop\\n{\\n\\tLaptop()\\n\\t{\\n\\t\\tSystem.out.println(\"Constructor of Laptop class.\");\\n\\t}\\n\\tvoid laptop_method()\\n\\t{\\n\\t\\tSystem.out.println(\"99% Battery available.\");\\n\\t\\t}\\n}",
            "OPT_A" : "Constructor of Computer class.\\nConstructor of Laptop class.\\nPower gone! Shut down your PC soon...\\n99% Battery available.\\n",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 14 ,
            "Q_TEXT" : "Default Constructor",
            "Q_PRGM" : "class Programming\\n{\\n\\tProgramming()\\n\\t{\\n\\t\\tSystem.out.println(\"Constructor method called.\");\\n\\t}\\n\\tpublic static void main(String[] args)\\n\\t{\\n\\tProgramming object = new Programming();\\n\\t}\\n}",
            "OPT_A" : "Constructor method called.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 15 ,
            "Q_TEXT" : "Constructor Overloading",
            "Q_PRGM" : "class Language\\n{\\n\\tString name;\\n\\tLanguage()\\n\\t{\\n\\t\\tSystem.out.println(\"Constructor method called.\");\\n\\t}\\n\\tLanguage(String t) \\n\\t{\\n\\t\\tname = t;\\n\\t}\\n\\tpublic static void main(String[] args)\\n\\t{\\n\\t\\tLanguage cpp  = new Language();\\n\\t\\tLanguage java = new Language(\"Java\");\\n\\t\\tcpp.setName(\"C++\");\\n\\t\\tjava.getName();\\n\\t\\tcpp.getName();\\n\\t}\\n\\tvoid setName(String t)\\n\\t{\\n\\t\\tname = t;\\n\\t}\\n\\tvoid getName()\\n\\t{\\n\\t\\tSystem.out.println(\"Language name: \" + name);\\n\\t}\\n}",
            "OPT_A" : "Constructor method called .\\nLanguage name : Java.\\nLanguage name : C++.\\n",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 16 ,
            "Q_TEXT" : "Constructor Chaining",
            "Q_PRGM" : "class GrandParent\\n{\\n\\tint a;\\n\\tGrandParent(int a)\\n\\t{\\n\\t\\tthis.a = a;\\n\\t}\\n\\t}\\nclass Parent extends GrandParent\\n{\\n\\tint b;\\n\\tParent(int a, int b)\\n\\t{\\n\\t\\tsuper(a);\\n\\t\\tthis.b = b;\\n\\t}\\n\\tvoid show()\\n\\t{\\n\\t\\tSystem.out.println(\"GrandParent's a = \" + a);\\n\\t\\tSystem.out.println(\"Parent's b = \" + b);\\n\\t}\\n}\\nclass Child\\n{\\n\\tpublic static void main(String[] args)\\n\\t{\\n\\t\\tParent object = new Parent(8, 9);\\n\\t\\tobject.show();\\n\\t}\\n}",
            "OPT_A" : "Grandparent's a = 8.\\nParent's b = 9.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 17 ,
            "Q_TEXT" : "Exception Handling",
            "Q_PRGM" : "class Division\\n{\\n\\tpublic static void main(String[] args)\\n\\t{\\n\\t\\tint a, b, result;\\n\\t\\tScanner input = new Scanner(System.in);\\n\\t\\tSystem.out.println(\"Input two integers\");\\n\\t\\ta = input.nextInt();\\n\\t\\tb = input.nextInt();\\n\\ttry\\n\\t{\\n\\t\\tresult  = a / b;\\n\\t\\tSystem.out.println(\"Result = \" + result);\\n\\t}\\n\\tcatch(ArithmeticException e)\\n\\t{\\n\\t\\tSystem.out.println(\"Exception caught: Division by zero.\");\\n\\t\\t}\\n\\t}\\n}",
            "OPT_A" : "Input two integers\\n4\\n2\\nResult=2\\nInput two integers\\n6\\n0\\nException caught: Division by zero.\\n",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 18 ,
            "Q_TEXT" : "Swapping two numbers",
            "Q_PRGM" : "import java.util.Scanner;\\nclass SwapNumbers\\n{\\n\\tpublic static void main(String args[])\\n\\t{\\n\\t\\tint x, y, temp;\\n\\t\\tSystem.out.println(\"Enter x and y\");\\n\\t\\tScanner in = new Scanner(System.in);\\n\\t\\tx = in.nextInt();\\n\\t\\ty = in.nextInt();\\n\\t\\tSystem.out.println(\"Before Swapping\nx = \"+x+\"\ny = \"+y);\\n\\t\\ttemp = x;\\n\\t\\tx = y;\\n\\t\\ty = temp;\\n\\t\\tSystem.out.println(\"After Swapping\nx = \"+x+\"\ny = \"+y);\\n\\t}\\n}",
            "OPT_A" : "Enter x and y\\n4\\n5\\nBefore Swapping\\na=4\\nb=5\\nAfter Swapping\\na=5\\nb=4",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 19 ,
            "Q_TEXT" : "Interface",
            "Q_PRGM" : "interface Info\\n{\\n\\tstatic final String language = \"Java\";\\n\\tpublic void display();\\n\\t}\\nclass Simple implements Info\\n{\\n\\tpublic static void main(String []args)\\n\\t{\\n\\t\\tSimple obj = new Simple();\\n\\t\\tobj.display();\\n\\t\\t}\\n\\tpublic void display()\\n\\t{\\n\\t\\tSystem.out.println(language + \"is awesome\");\\n\\t}\\n}",
            "OPT_A" : "Java is awesome",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 20 ,
            "Q_TEXT" : "Garbage Collection",
            "Q_PRGM" : "import java.util.*;\\nclass GarbageCollection\\n{\\n\\tpublic static void main(String s[]) throws Exception\\n\\t{\\n\\t\\tRuntime rs =  Runtime.getRuntime();\\n\\t\\tSystem.out.println(\"Free memory in JVM before Garbage Collection = \"+rs.freeMemory());\\n\\t\\trs.gc();\\n\\t\\tSystem.out.println(\"Free memory in JVM after Garbage Collection = \"+rs.freeMemory());\\n\\t}\\n}",
            "OPT_A" : "Free memory in JVM before Garbage Collection = 61738736\\nFree memory in JVM after Garbage Collection = 61501329",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 21 ,
            "Q_TEXT" : "Multithreading in Java",
            "Q_PRGM" : "class RunnableDemo implements Runnable\\n{\\n\\tprivate Thread t;\\n\\tprivate String threadName;\\n\\tRunnableDemo( String name)\\n\\t{\\n\\t\\tthreadName = name;\\n\\t\\tSystem.out.println(\"Creating\" +  threadName);\\n\\t\\t}\\n\\tpublic void run()\\n\\t{\\n\\t\\tSystem.out.println(\"Running\" +  threadName);\\n\\t\\ttry\\n\\t\\t{\\n\\t\\t\\tfor(int i = 4; i > 0; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tSystem.out.println(\"Thread:\" + threadName + \", \" + i);\\n\\t\\t\\t\\tThread.sleep(50);\\n\\t\\t\\t}\\n\\t\\t}\\n\\tcatch(InterruptedException e)\\n\\t\\t{\\n\\t\\t\\tSystem.out.println(\"Thread \" +  threadName + \" interrupted.\");\\n\\t\\t\\t}\\n\\t\\tSystem.out.println(\"Thread \" +  threadName + \" exiting.\");\\n\\t}\\n\\tpublic void start ()\\n\\t{\\n\\t\\tystem.out.println(\"Starting \" +  threadName);\\n\\t\\tif (t == null)\\n\\t\\t{\\n\\t\\t\\tt = new Thread (this, threadName);\\n\\t\\t\\tt.start ();\\n\\t\\t\\t}\\n\\t}\\n}\\npublic class TestThread\\n{\\n\\tpublic static void main(String args[])\\n\\t{\\n\\tRunnableDemo R1 = new RunnableDemo(\"Thread-1\");\\n\\t\\tR1.start();\\n\\t\\tRunnableDemo R2 = new RunnableDemo(\"Thread-2\");\\n\\t\\tR2.start();\\n\\t}\\n}",
            "OPT_A" : "Creating Thread-1\\nStarting Thread-1\\nCreating Thread-2\\nStarting Thread-2\\nRunning Thread-1\\nThread: Thread-1, 4\\nRunning Thread-2\\nThread: Thread-2, 4\\nThread: Thread-1, 3\\nThread: Thread-2, 3\\nThread: Thread-1, 2\\nThread: Thread-2, 2\\nThread: Thread-1, 1\\nThread: Thread-2, 1\\nThread Thread-1 exiting.\\nThread Thread-2 exiting.\\n",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 22 ,
            "Q_TEXT" : "Applet-Smiley",
            "Q_PRGM" : "import java.awt.*;\\nimport java.applet.*;\\npublic class Smiley extends Applet\\n{\\n\\tpublic void paint(Graphics g)\\n\\t\\t{\\n\\t\\t\\tFont f = new Font(\"Helvetica\", Font.BOLD,20);\\n\\t\\t\\tg.setFont(f);\\n\\t\\t\\tg.drawString(\"Keep Smiling!!!\", 50, 30);\\n\\t\\t\\tg.drawOval(60, 60, 200, 200);\\n\\t\\t\\tg.fillOval(90, 120, 50, 20);\\n\\t\\t\\tg.fillOval(190, 120, 50, 20);\\n\\t\\t\\tg.drawLine(165, 125, 165, 175);\\n\\t\\t\\tg.drawArc(110, 130, 95, 95, 0, -180);\\n\\t\\t}\\n}",
            "OPT_A" : "OUTPUT",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 23 ,
            "Q_TEXT" : "Different shapes in java using Applet",
            "Q_PRGM" : "import java.awt.*;\\nimport java.applet.*;\\npublic class DrawExample extends Applet\\n{\\n\\tFont bigFont;\\n\\tColor redColor;\\n\\tColor weirdColor;\\n\\tColor bgColor;\\n\\tpublic void init()\\n\\t{\\n\\t\\tbigFont = new Font(\"Arial\",Font.BOLD,16);\\n\\t\\tredColor = Color.red;\\n\\t\\tweirdColor = new Color(60,60,122);\\n\\t\\tbgColor = Color.blue;\\n\\t\\tsetBackground(bgColor);\\n\\t}\\n\\tpublic void paint(Graphics g)\\n\\t{\\n\\t\\tg.setFont(bigFont);\\n\\t\\tg.drawString(\"Shapes and Colors\",80,20);\\n\\t\\tg.setColor(redColor);\\n\\t\\t g.drawRect(100,100,100,100);\\n\\t\\tg.fillRect(110,110,80,80);\\n\\t\\tg.setColor(weirdColor);\\n\\t\\tcircle (int x, int y, int width, int height,int startAngle, int arcAngle);\\n\\t\\tg.fillArc(120,120,60,60,0,360);\\n\\t\\tg.setColor(Color.yellow);\\n\\t\\tg.drawLine(140,140,160,160);\\n\\t\\tg.setColor(Color.black);\\n\\t\\t}\\n\\t}",
            "OPT_A" : "OUTPUT",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          }
        ]
      },
      {
        "LEVEL_ID": 2,
        "LEVEL_NAME": "Theory",
        "LOCK_STATUS": 1,
        "QUESTIONS": [
          {
            "Q_ID" : 1,
            "Q_TEXT" : "Introduction",
            "Q_PRGM" : "Java is a general-purpose computer programming language that is concurrent, class-based, object-oriented, and specifically designed to have as few implementation dependencies as possible. It is intended to let application developers \"write once, run anywhere\" (WORA), meaning that compiled Java code can run on all platforms that support Java without the need for recompilation. Java applications are typically compiled to bytecode that can run on any Java virtual machine (JVM) regardless ofcomputer architecture. As of 2016, Java is one of the most popular programming languages in use, particularly for client-server web applications, with a reported 9 million developers. Java was originally developed by James Gosling at Sun Microsystems (which has since been acquired by Oracle Corporation) and released in 1995 as a core component of Sun Microsystems' Java platform. The language derives much of its syntax from C and C++, but it has fewer low-level facilities than either of them.\\nThe original and reference implementation Java compilers, virtual machines, and class libraries were originally released by Sun under proprietary licences. As of May 2007, in compliance with the specifications of the Java Community Process, Sun relicensed most of its Java technologies under the GNU General Public License. Others have also developed alternative implementations of these Sun technologies, such as the GNU Compiler for Java (bytecode compiler), GNU Classpath (standard libraries), and IcedTea-Web (browser plugin for applets).\\nThe latest version is Java 8, which is the only version currently supported for free by Oracle, although earlier versions are supported both by Oracle and other companies on a commercial basis.",
            "OPT_A" : " The language derives much of its syntax from C and C++, but it has fewer low-level facilities than either of them.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 2,
            "Q_TEXT" : "History",
            "Q_PRGM" : "James Gosling, Mike Sheridan, and Patrick Naughton initiated the Java language project in June 1991. Java was originally designed for interactive television, but it was too advanced for the digital cable television industry at the time. The language was initially called Oak after anoak tree that stood outside Gosling's office. Later the project went by the name Green and was finally renamed Java, from Java coffee. Gosling designed Java with a C/C++-style syntax that system and application programmers would find familiar.\\nSun Microsystems released the first public implementation as Java 1.0 in 1995. It promised \"Write Once, Run Anywhere\" (WORA), providing no-cost run-times on popular platforms. Fairly secure and featuring configurable security, it allowed network- and file-access restrictions. Major web browsers soon incorporated the ability to run Java applets within web pages, and Java quickly became popular. The Java 1.0 compiler was re-written in Java by Arthur van Hoff to comply strictly with the Java 1.0 language specification. With the advent of Java 2 (released initially as J2SE 1.2 in December 1998 – 1999), new versions had multiple configurations built for different types of platforms. J2EE included technologies and APIs for enterprise applications typically run in server environments, while J2ME featured APIs optimized for mobile applications. The desktop version was renamed J2SE. In 2006, for marketing purposes, Sun renamed new J2 versions as Java EE, Java ME, and Java SE, respectively.\\nIn 1997, Sun Microsystems approached the ISO/IEC JTC 1 standards body and later the Ecma International to formalize Java, but it soon withdrew from the process. Java remains a de facto standard, controlled through the Java Community Process. At one time, Sun made most of its Java implementations available without charge, despite their proprietary software status. Sun generated revenue from Java through the selling of licenses for specialized products such as the Java Enterprise System.\\nOn November 13, 2006, Sun released much of its Java virtual machine (JVM) as free and open-source software, (FOSS), under the terms of the GNU General Public License (GPL). On May 8, 2007, Sun finished the process, making all of its JVM's core code available underfree software/open-source distribution terms, aside from a small portion of code to which Sun did not hold the copyright.\\nSun's vice-president Rich Green said that Sun's ideal role with regard to Java was as an \"evangelist\". Following Oracle Corporation's acquisition of Sun Microsystems in 2009–10, Oracle has described itself as the \"steward of Java technology with a relentless commitment to fostering a community of participation and transparency\". This did not prevent Oracle from filing a lawsuit against Google shortly after that for using Java inside the Android SDK (see Google section below). Java software runs on everything from laptops to data centers, game consoles to scientific supercomputers. On April 2, 2010, James Gosling resigned from Oracle.",
            "OPT_A" : "Java was originally known as Oak",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 3,
            "Q_TEXT" : "Principles",
            "Q_PRGM" : "There were five primary goals in the creation of the Java language:\\n1.	It must be \"simple, object-oriented, and familiar\".\\n2.	It must be \"robust and secure\".\\n3.	It must be \"architecture-neutral and portable\".\\n4.	It must execute with \"high performance\".\\n5.	It must be \"interpreted, threaded, and dynamic\".",
            "OPT_A" : "Gosling designed Java with a C/C++-style syntax that system and application programmers would find familiar.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 4,
            "Q_TEXT" : "Versions",
            "Q_PRGM" : "Major release versions of Java, along with their release dates:\\n•	JDK 1.0 (January 21, 1996)\\n•	JDK 1.1 (February 19, 1997)\\n•	J2SE 1.2 (December 8, 1998)\\n•	J2SE 1.3 (May 8, 2000)\\n•	J2SE 1.4 (February 6, 2002)\\n•	J2SE 5.0 (September 30, 2004)\\n•	Java SE 6 (December 11, 2006)\\n•	Java SE 7 (July 28, 2011)\\n•	Java SE 8 (March 18, 2014)",
            "OPT_A" : "As of 2015, only Java 8 is supported (\"publicly\").",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 5,
            "Q_TEXT" : "Java platform",
            "Q_PRGM" : "One design goal of Java is portability, which means that programs written for the Java platform must run similarly on any combination of hardware and operating system with adequate runtime support. This is achieved by compiling the Java language code to an intermediate representation called Java bytecode, instead of directly to architecture-specific machine code. Java bytecode instructions are analogous to machine code, but they are intended to be executed by a virtual machine (VM) written specifically for the host hardware. End userscommonly use a Java Runtime Environment (JRE) installed on their own machine for standalone Java applications, or in a web browser for Java applets.\\nStandard libraries provide a generic way to access host-specific features such as graphics, threading, and networking.\\nThe use of universal bytecode makes porting simple. However, the overhead of interpreting bytecode into machine instructions makes interpreted programs almost always run more slowly than native executables. However, just-in-time (JIT) compilers that compile bytecodes to machine code during runtime were introduced from an early stage. Java itself is platform-independent, and is adapted to the particular platform it is to run on by a Java virtual machine for it, which translates the Java bytecode into the platform's machine language.",
            "OPT_A" : "Java bytecode instructions are analogous to machine code, but they are intended to be executed by a java virtual machine (JVM)",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 6,
            "Q_TEXT" : "Implementations",
            "Q_PRGM" : "Oracle Corporation is the current owner of the official implementation of the Java SE platform, following their acquisition of Sun Microsystems on January 27, 2010. This implementation is based on the original implementation of Java by Sun. The Oracle implementation is available for Microsoft Windows (still works for XP, while only later versions currently \"publicly\" supported), Mac OS X, Linux and Solaris. Because Java lacks any formal standardization recognized by Ecma International, ISO/IEC, ANSI, or other third-party standards organization, the Oracle implementation is the de facto standard.\\nThe Oracle implementation is packaged into two different distributions: The Java Runtime Environment (JRE) which contains the parts of the Java SE platform required to run Java programs and is intended for end users, and the Java Development Kit (JDK), which is intended for software developers and includes development tools such as the Java compiler, Javadoc, Jar, and a debugger.\\nOpenJDK is another notable Java SE implementation that is licensed under the GNU GPL. The implementation started when Sun began releasing the Java source code under the GPL. As of Java SE 7, OpenJDK is the official Java reference implementation.\\nThe goal of Java is to make all implementations of Java compatible. Historically, Sun's trademark license for usage of the Java brand insists that all implementations be \"compatible\". This resulted in a legal dispute with Microsoft after Sun claimed that the Microsoft implementation did not support RMI or JNI and had added platform-specific features of their own. Sun sued in 1997, and in 2001 won a settlement of US$20 million, as well as a court order enforcing the terms of the license from Sun. As a result, Microsoft no longer ships Java with Windows.\\nPlatform-independent Java is essential to Java EE, and an even more rigorous validation is required to certify an implementation. This environment enables portable server-side applications.",
            "OPT_A" : "The Oracle implementation is packaged into two different distributions: The Java Runtime Environment (JRE) which contains the parts of the Java SE platform required to run Java programs and is intended for end users, and the Java Development Kit (JDK), which is intended for software developers and includes development tools such as the Java compiler, Javadoc, Jar, and a debugger.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 7,
            "Q_TEXT" : "Performance",
            "Q_PRGM" : "Programs written in Java have a reputation for being slower and requiring more memory than those written in C++. However, Java programs' execution speed improved significantly with the introduction of just-in-time compilation in 1997/1998 for Java 1.1, the addition of language features supporting better code analysis (such as inner classes, the StringBuilder class, optional assertions, etc.), and optimizations in the Java virtual machine, such as HotSpot becoming the default for Sun's JVM in 2000.\\nSome platforms offer direct hardware support for Java; there are microcontrollers that can run Java in hardware instead of a software Java virtual machine, and ARM based processors can have hardware support for executing Java bytecode through their Jazelle option (while its support is mostly dropped in current implementations of ARM).",
            "OPT_A" : "Some platforms offer direct hardware support for Java; there are microcontrollers that can run Java in hardware instead of a software Java virtual machine",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 8,
            "Q_TEXT" : "Automatic memory management",
            "Q_PRGM" : "Java uses an automatic garbage collector to manage memory in the object lifecycle. The programmer determines when objects are created, and the Java runtime is responsible for recovering the memory once objects are no longer in use. Once no references to an object remain, the unreachable memory becomes eligible to be freed automatically by the garbage collector. Something similar to a memory leak may still occur if a programmer's code holds a reference to an object that is no longer needed, typically when objects that are no longer needed are stored in containers that are still in use. If methods for a nonexistent object are called, a \"null pointer exception\" is thrown.\\nOne of the ideas behind Java's automatic memory management model is that programmers can be spared the burden of having to perform manual memory management. In some languages, memory for the creation of objects is implicitly allocated on the stack, or explicitly allocated and deallocated from the heap. In the latter case the responsibility of managing memory resides with the programmer. If the program does not deallocate an object, a memory leak occurs. If the program attempts to access or deallocate memory that has already been deallocated, the result is undefined and difficult to predict, and the program is likely to become unstable and/or crash. This can be partially remedied by the use of smart pointers, but these add overhead and complexity. Note that garbage collection does not prevent \"logical\" memory leaks, i.e., those where the memory is still referenced but never used.\\nGarbage collection may happen at any time. Ideally, it will occur when a program is idle. It is guaranteed to be triggered if there is insufficient free memory on the heap to allocate a new object; this can cause a program to stall momentarily. Explicit memory management is not possible in Java.\\nJava does not support C/C++ style pointer arithmetic, where object addresses and unsigned integers (usually long integers) can be used interchangeably. This allows the garbage collector to relocate referenced objects and ensures type safety and security.\\nAs in C++ and some other object-oriented languages, variables of Java's primitive data types are either stored directly in fields (for objects) or on the stack (for methods) rather than on the heap, as is commonly true for non-primitive data types (but see escape analysis). This was a conscious decision by Java's designers for performance reasons.\\nJava contains multiple types of garbage collectors. By default, HotSpot uses the parallel scavenge garbage collector. However, there are also several other garbage collectors that can be used to manage the heap. For 90% of applications in Java, the Concurrent Mark-Sweep garbage collector is sufficient. Oracle aims to replace CMS with the Garbage-first collector (G1).",
            "OPT_A" : "Java does not support C/C++ style pointer arithmetic",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 9,
            "Q_TEXT" : "Syntax",
            "Q_PRGM" : "The syntax of Java is largely influenced by C++. Unlike C++, which combines the syntax for structured, generic, and object-oriented programming, Java was built almost exclusively as an object-oriented language. All code is written inside classes, and every data item is an object, with the exception of the primitive data types, i.e. integers, floating-point numbers, boolean values, and characters, which are not objects for performance reasons. Java reuses some popular aspects of C++ (such as printf() method).\\nUnlike C++, Java does not support operator overloading or multiple inheritance for classes, though multiple inheritance is supported for interfaces. This simplifies the language and aids in preventing potential errors and anti-pattern design.\\nJava uses comments similar to those of C++. There are three different styles of comments: a single line style marked with two slashes (//), a multiple line style opened with /*and closed with */, and the Javadoc commenting style opened with /** and closed with */. The Javadoc style of commenting allows the user to run the Javadoc executable to create documentation for the program.",
            "OPT_A" : "Unlike C++, Java does not support operator overloading or multiple inheritance for classes",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 10,
            "Q_TEXT" : "Syntax",
            "Q_PRGM" : "The syntax of Java is largely influenced by C++. Unlike C++, which combines the syntax for structured, generic, and object-oriented programming, Java was built almost exclusively as an object-oriented language. All code is written inside classes, and every data item is an object, with the exception of the primitive data types, i.e. integers, floating-point numbers, boolean values, and characters, which are not objects for performance reasons. Java reuses some popular aspects of C++ (such as printf() method).\\nUnlike C++, Java does not support operator overloading or multiple inheritance for classes, though multiple inheritance is supported for interfaces. This simplifies the language and aids in preventing potential errors and anti-pattern design.\\nJava uses comments similar to those of C++. There are three different styles of comments: a single line style marked with two slashes (//), a multiple line style opened with /*and closed with */, and the Javadoc commenting style opened with /** and closed with */. The Javadoc style of commenting allows the user to run the Javadoc executable to create documentation for the program.Source files must be named after the public class they contain, appending the suffix .java, for example, HelloWorldApp.java. It must first be compiled into bytecode, using aJava compiler, producing a file named HelloWorldApp.class. Only then can it be executed, or \"launched\". The Java source file may only contain one public class, but it can contain multiple classes with other than public access and any number of public inner classes. When the source file contains multiple classes, make one class \"public\" and name the source file with that public class name.\\nA class that is not declared public may be stored in any .java file. The compiler will generate a class file for each class defined in the source file. The name of the class file is the name of the class, with .class appended. For class file generation, anonymous classes are treated as if their name were the concatenation of the name of their enclosing class, a $, and an integer.\\nThe keyword public denotes that a method can be called from code in other classes, or that a class may be used by classes outside the class hierarchy. The class hierarchy is related to the name of the directory in which the .java file is located. This is called an access level modifier. Other access level modifiers include the keywords private , andprotected.\\nThe keyword static in front of a method indicates a static method, which is associated only with the class and not with any specific instance of that class. Only static methods can be invoked without a reference to an object. Static methods cannot access any class members that are not also static. Methods that are not designated static are instance methods, and require a specific instance of a class to operate.\\nThe keyword void indicates that the main method does not return any value to the caller. If a Java program is to exit with an error code, it must call System.exit() explicitly.\\nThe method name \"main\" is not a keyword in the Java language. It is simply the name of the method the Java launcher calls to pass control to the program. Java classes that run in managed environments such as applets and Enterprise JavaBeans do not use or need a main() method. A Java program may contain multiple classes that have mainmethods, which means that the VM needs to be explicitly told which class to launch from.\\nThe main method must accept an array of String objects. By convention, it is referenced as args although any other legal identifier name can be used. Since Java 5, the main method can also use variable arguments, in the form of public static void main(String... args), allowing the main method to be invoked with an arbitrary number of String arguments. The effect of this alternate declaration is semantically identical (the args parameter is still an array of String objects), but it allows an alternative syntax for creating and passing the array.\\nThe Java launcher launches Java by loading a given class (specified on the command line or as an attribute in a JAR) and starting its public static void main(String[])method. Stand-alone programs must declare this method explicitly. The String[] args parameter is an array of String objects containing any arguments passed to the class. The parameters to main are often passed by means of a command line.\\nPrinting is part of a Java standard library: The System class defines a public static field called out. The out object is an instance of the PrintStream class and provides many methods for printing data to standard out, including println(String) which also appends a new line to the passed string.\\nThe string \"Hello World!\" is automatically converted to a String object by the compiler.",
            "OPT_A" : "Unlike C++, Java does not support operator overloading or multiple inheritance for classes",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 11,
            "Q_TEXT" : "Applet",
            "Q_PRGM" : "Java applets are programs that are embedded in other applications, typically in a Web page displayed in a web browser.The import statements direct the Java compiler to include the javax.swing.JApplet and java.awt.Graphics classes in the compilation. The import statement allows these classes to be referenced in the source code using the simple class name (i.e. JApplet) instead of the fully qualified class name (FQCN, i.e. javax.swing.JApplet).\\nThe Hello class extends (subclasses) the JApplet (Java Applet) class; the JApplet class provides the framework for the host application to display and control thelifecycle of the applet. The JApplet class is a JComponent (Java Graphical Component) which provides the applet with the capability to display a graphical user interface (GUI) and respond to user events.\\nThe Hello class overrides the paintComponent(Graphics) method (additionally indicated with the annotation, supported as of JDK 1.5, Override) inherited from theContainer superclass to provide the code to display the applet. The paintComponent() method is passed a Graphics object that contains the graphic context used to display the applet. The paintComponent() method calls the graphic context drawString(String, int, int) method to display the \"Hello, world!\" string at a pixel offset of (65, 95) from the upper-left corner in the applet's display.\\nAn applet is placed in an HTML document using the <applet> HTML element. The applet tag has three attributes set: code=\"Hello\" specifies the name of the JAppletclass and width=\"200\" height=\"200\" sets the pixel width and height of the applet. Applets may also be embedded in HTML using either the object or embed element,although support for these elements by web browsers is inconsistent. However, the applet tag is deprecated, so the object tag is preferred where supported.\\nThe host application, typically a Web browser, instantiates the Hello applet and creates an AppletContext for the applet. Once the applet has initialized itself, it is added to the AWT display hierarchy. The paintComponent() method is called by the AWT event dispatching thread whenever the display needs the applet to draw itself.",
            "OPT_A" : "The JApplet class provides the framework for the host application to display and control the lifecycle of the applet. ",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 12,
            "Q_TEXT" : "Servlet",
            "Q_PRGM" : "Java Servlet technology provides Web developers with a simple, consistent mechanism for extending the functionality of a Web server and for accessing existing business systems. Servlets are server-side Java EE components that generate responses (typically HTML pages) to requests (typically HTTP requests) from clients. A servlet can almost be thought of as an applet that runs on the server side—without a face.\\nThe import statements direct the Java compiler to include all the public classes and interfaces from the java.io and javax.servlet packages in the compilation. Packages make Java well suited for large scale applications.\\nThe Hello class extends the GenericServlet class; the GenericServlet class provides the interface for the server to forward requests to the servlet and control the servlet's lifecycle.\\nThe Hello class overrides the service(ServletRequest, ServletResponse) method defined by the Servlet interface to provide the code for the service request handler. The service() method is passed: a ServletRequest object that contains the request from the client and a ServletResponse object used to create the response returned to the client. The service() method declares that it throws the exceptions ServletException and IOException if a problem prevents it from responding to the request.\\nThe setContentType(String) method in the response object is called to set the MIME content type of the returned data to \"text/html\". The getWriter() method in the response returns a PrintWriter object that is used to write the data that is sent to the client. The println(String) method is called to write the \"Hello, world!\" string to the response and then the close() method is called to close the print writer, which causes the data that has been written to the stream to be returned to the client.",
            "OPT_A" : "A servlet can almost be thought of as an applet that runs on the server side—without a face.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 13,
            "Q_TEXT" : "JavaServer Pages",
            "Q_PRGM" : "JavaServer Pages (JSP) are server-side Java EE components that generate responses, typically HTML pages, to HTTP requests from clients. JSPs embed Java code in an HTML page by using the special delimiters <% and %>. A JSP is compiled to a Java servlet, a Java application in its own right, the first time it is accessed. After that, the generated servlet creates the response.",
            "OPT_A" : "JSP consists of both html tags and also tha java code encoporated within <% and %>",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 14,
            "Q_TEXT" : "Swing application",
            "Q_PRGM" : "Swing is a graphical user interface library for the Java SE platform. It is possible to specify a different look and feel through the pluggable look and feel system of Swing. Clones ofWindows, GTK+ and Motif are supplied by Sun. Apple also provides an Aqua look and feel for Mac OS X. Where prior implementations of these looks and feels may have been considered lacking, Swing in Java SE 6 addresses this problem by using more native GUI widget drawing routines of the underlying platforms.\\nThe import includes all the public classes and interfaces from the javax.swing package.\\nThe Hello class extends the JFrame class; the JFrame class implements a window with a title bar and a close control.\\nThe Hello() constructor initializes the frame by first calling the superclass constructor, passing the parameter \"hello\", which is used as the window's title. It then calls thesetDefaultCloseOperation(int) method inherited from JFrame to set the default operation when the close control on the title bar is selected toWindowConstants.EXIT_ON_CLOSE – this causes the JFrame to be disposed of when the frame is closed (as opposed to merely hidden), which allows the Java virtual machine to exit and the program to terminate. Next, a JLabel is created for the string \"Hello, world!\" and the add(Component) method inherited from the Containersuperclass is called to add the label to the frame. The pack() method inherited from the Window superclass is called to size the window and lay out its contents.\\nThe main() method is called by the Java virtual machine when the program starts. It instantiates a new Hello frame and causes it to be displayed by calling thesetVisible(boolean) method inherited from the Component superclass with the boolean parameter true. Once the frame is displayed, exiting the main method does not cause the program to terminate.",
            "OPT_A" : "AWT event dispatching thread remains active until all of the Swing top-level windows have been disposed.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 15,
            "Q_TEXT" : "Generics",
            "Q_PRGM" : "In 2004, generics were added to the Java language, as part of J2SE 5.0. Prior to the introduction of generics, each variable declaration had to be of a specific type. For container classes, for example, this is a problem because there is no easy way to create a container that accepts only specific types of objects. Either the container operates on all subtypes of a class or interface, usually Object, or a different container class has to be created for each contained class. Generics allow compile-time type checking without having to create many container classes, each containing almost identical code. In addition to enabling more efficient code, certain runtime exceptions are converted to compile-time errors, a characteristic known as type safety.",
            "OPT_A" : "Either the container operates on all subtypes of a class or interface, usually Object, or a different container class has to be created for each contained class",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          }
        ]
      },
      {
        "LEVEL_ID": 3,
        "LEVEL_NAME": "Miscellaneous",
        "LOCK_STATUS": 1,
        "QUESTIONS": [
          {
            "Q_ID": 1,
            "Q_TEXT": "What is the range of data type short in Java?",
            "Q_PRGM": "",
            "OPT_A": "-128 to 127",
            "OPT_B": "-32768 to 32767",
            "OPT_C": "-2147483648 to 2147483647",
            "OPT_D": "None of the mentioned",
            "ANSWER": 2
          },
          {
            "Q_ID": 2,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "class average \\n{\\n\\tpublic static void main(String args[])\\n\\t{\\n\\t\\tdouble num[] = {5.5, 10.1, 11, 12.8, 56.9, 2.5};\\n\\t\\tdouble result;\\n\\t\\tresult = 0;\\n\\t\\tfor (int i = 0; i < 6; ++i) \\n\\t\\t\\tresult = result + num[i];\\n\\t\\tSystem.out.print(result/6);\\n \\t} \\n}",
            "OPT_A": "16.34",
            "OPT_B": "16.566666644",
            "OPT_C": "16.46666666666667",
            "OPT_D": "16.46666666666666",
            "ANSWER": 3
          },
          {
            "Q_ID": 3,
            "Q_TEXT": "Which data type value is returned by all transcendental math functions?",
            "Q_PRGM": "",
            "OPT_A": "int",
            "OPT_B": "float",
            "OPT_C": "double",
            "OPT_D": "long",
            "ANSWER": 3
          },
          {
            "Q_ID": 4,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "class conversion\\n{\\n\\tpublic static void main(String args[]) \\n\\t{\\n\\t\\tdouble a = 295.04;\\n\\t\\tint  b = 300;\\n\\t\\tbyte c = (byte) a;\\n\\t\\tbyte d = (byte) b;\\n\\t\\tSystem.out.println(c + \" \"  + d);\\n\\t} }",
            "OPT_A": "38 43",
            "OPT_B": "39 44",
            "OPT_C": " 295 300",
            "OPT_D": "295.04 300",
            "ANSWER": 2
          },
          {
            "Q_ID": 5,
            "Q_TEXT": "Which of these coding types is used for data type characters in Java?",
            "Q_PRGM": "",
            "OPT_A": "ASCII",
            "OPT_B": "ISO-LATIN-1",
            "OPT_C": "UNICODE",
            "OPT_D": "None of the mentioned",
            "ANSWER": 3
          },
          {
            "Q_ID": 6,
            "Q_TEXT": " What is the output of this program?",
            "Q_PRGM": "class array_output\\n{\\n\\tpublic static void main(String args[]) \\n\\t{\\n\\t\\tchar array_variable [] = new char[10];\\n\\t\\t\\tfor (int i = 0; i < 10; ++i) {\\n\\t\\t\\t\\tarray_variable[i] = 'i';\\n\\t\\t\\t\\tSystem.out.print(array_variable[i] + \"  \" );\\n\\t\\t\\t\\ti++;\\t\\t\\t}\\t\\t} \\t}",
            "OPT_A": "i i i i i",
            "OPT_B": "0 1 2 3 4",
            "OPT_C": "i j k l m",
            "OPT_D": "None of the mentioned",
            "ANSWER": 1
          },
          {
            "Q_ID": 7,
            "Q_TEXT": " Which of these is incorrect string literal?",
            "Q_PRGM": "",
            "OPT_A": "“Hello World”",
            "OPT_B": "“Hello\nWorld”",
            "OPT_C": " “”Hello World””",
            "OPT_D": " “Hello\\nworld”",
            "ANSWER": 4
          },
          {
            "Q_ID": 8,
            "Q_TEXT": " What is the output of this program?",
            "Q_PRGM": "class dynamic_initialization \\n{\\n\\tpublic static void main(String args[]) \\n\\t{\\n\\t\\tdouble a, b;\\n\\t\\ta = 3.0;\\n\\t\\tb = 4.0;\\n\\t\\tdouble c = Math.sqrt(a * a + b * b);\\n\\t\\tSystem.out.println(c);\\n\\t} \\n}",
            "OPT_A": "5.0",
            "OPT_B": "25.0",
            "OPT_C": "7.0",
            "OPT_D": "Compilation Error",
            "ANSWER": 1
          },
          {
            "Q_ID": 9,
            "Q_TEXT": "Which of these operators is used to allocate memory to array variable in Java?",
            "Q_PRGM": "",
            "OPT_A": "malloc",
            "OPT_B": "alloc",
            "OPT_C": "new",
            "OPT_D": "new malloc",
            "ANSWER": 3
          },
          {
            "Q_ID": 10,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "class evaluate \\n{\\n\\tpublic static void main(String args[]) \\n\\t{\\n\\t\\tint arr[] = new int[] {0 , 1, 2, 3, 4, 5, 6, 7, 8, 9};\\n\\t\\tint n = 6;\\n\\t\\tn = arr[arr[n] / 2];\\n\\t\\tSystem.out.println(arr[n] / 2);\\n\\t}\\n}",
            "OPT_A": "3",
            "OPT_B": "0",
            "OPT_C": "6",
            "OPT_D": "1",
            "ANSWER": 4
          },
          {
            "Q_ID": 11,
            "Q_TEXT": "Which of these is necessary to specify at time of array initialization?",
            "Q_PRGM": "",
            "OPT_A": "Row",
            "OPT_B": "Column",
            "OPT_C": "Both Row and Column",
            "OPT_D": "None of the mentioned",
            "ANSWER": 1
          },
          {
            "Q_ID": 12,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "class increment\\n{\\n\\tpublic static void main(String args[])\\n\\t{\\n\\t\\tdouble var1 = 1 + 5; \\n\\t\\tdouble var2 = var1 / 4;\\n\\t\\tint var3 = 1 + 5;\\t\n\\t\\tint var4 = var3 / 4;\\n\\t\\tSystem.out.print(var2 + \" \" + var4);\\n\\t} \\n}",
            "OPT_A": "1 1",
            "OPT_B": "0 1",
            "OPT_C": "1.5 1",
            "OPT_D": "1.5 1.0",
            "ANSWER": 3
          },
          {
            "Q_ID": 13,
            "Q_TEXT": " With x = 0, which of the following are legal lines of Java code for changing the value of x to 1?\\n1. x++;\\n2. x = x + 1;\\n3. x += 1;\\n4. x =+ 1;\\n",
            "Q_PRGM": "",
            "OPT_A": "1, 2 & 3",
            "OPT_B": "1 & 4",
            "OPT_C": "1, 2, 3 & 4",
            "OPT_D": "3 & 2",
            "ANSWER": 4
          },
          {
            "Q_ID": 14,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "class increment\\n {\\n\\tpublic static void main(String args[]) \\t\\t{\\n\\tint g = 3;\\n\\tSystem.out.print(++g * 8);\\n\\t} \\}",
            "OPT_A": "25",
            "OPT_B": "24",
            "OPT_C": "32",
            "OPT_D": "33",
            "ANSWER": 3
          },
          {
            "Q_ID": 15,
            "Q_TEXT": " What is the stored in the object obj in following lines of code?\\nbox obj;",
            "Q_PRGM": "",
            "OPT_A": "Memory address of allocated memory of object.",
            "OPT_B": "NULL",
            "OPT_C": "Any arbitrary pointer",
            "OPT_D": "Garbage",
            "ANSWER": 2
          },
          {
            "Q_ID": 16,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": " class main_class\\n {\\n\\tpublic static void main(String args[])\\n\\t{\\n\\t\\tint x = 9;\\n\\t\\tif (x == 9)\\n \\t\\t\\t{\\n \\t\\t\\tint x = 8;\\n\\t\\t\\tSystem.out.println(x);\\n\\t\\t}\\n\\t}\\n }",
            "OPT_A": "9",
            "OPT_B": "8",
            "OPT_C": "Compilation error",
            "OPT_D": "Runtime error",
            "ANSWER": 3
          },
          {
            "Q_ID": 17,
            "Q_TEXT": "Which operator is used by Java run time implementations to free the memory of an object when it is no longer needed?",
            "Q_PRGM": "",
            "OPT_A": "delete",
            "OPT_B": "free",
            "OPT_C": "new",
            "OPT_D": "None of the mentioned",
            "ANSWER": 4
          },
          {
            "Q_ID": 18,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "class test\\n{\\n\\tint a;\\n\\tint b;\\n\\tvoid meth(int i , int j)\\n\\t{\\n\\t\\ti *= 2;\\n\\t\\tj /= 2;\\n\\t}\\n}\\nclass Output\\n{\\n\\tpublic static void main(String args[])\\n\\t{\\n\\t\\ttest obj = new test();\\n\\t\\tint a = 10;\\n\\t\\tint b = 20;\\n\\t\\tobj.meth(a , b);\\n\\t\\tSystem.out.println(a + \" \" + b);\\n\\t} \\n}",
            "OPT_A": "10 20",
            "OPT_B": "20 10",
            "OPT_C": "20 40",
            "OPT_D": "40 20",
            "ANSWER": 1
          },
          {
            "Q_ID": 19,
            "Q_TEXT": " Which of these can be overloaded?",
            "Q_PRGM": "",
            "OPT_A": "Methods",
            "OPT_B": "Constructors",
            "OPT_C": "All of the mentioned",
            "OPT_D": "None of the mentioned",
            "ANSWER": 3
          },
          {
            "Q_ID": 20,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "class access//n{//n//tpublic int x;//n//tprivate int y;//n\\tvoid cal(int a, int b)\\t\\t{\\t\\t\\tx =  a + 1;\\n\\t\\ty =  b;\\n\\t}\\n}\\nclass access_specifier\\n{\\n\\tpublic static void main(String args[])\\n\\t{\\n\\t\\taccess obj = new access();\\n\\t\\tobj.cal(2, 3);\\n\\t\\tSystem.out.println(obj.x + \" \" + obj.y);\\n\\t}\\n}",
            "OPT_A": "3 3",
            "OPT_B": "2 3",
            "OPT_C": "Runtime Error",
            "OPT_D": "Compilation Error",
            "ANSWER": 3
          },
          {
            "Q_ID": 21,
            "Q_TEXT": "Which of these is used as default for a member of a class if no access specifier is used for it?",
            "Q_PRGM": "",
            "OPT_A": "private",
            "OPT_B": "public",
            "OPT_C": "public, within its own package",
            "OPT_D": "protected",
            "ANSWER": 1
          },
          {
            "Q_ID": 22,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "class static_out\\n{\\n\\tstatic int x;\\n\\tstatic int y;\\n\\tvoid add(int a , int b)\\n\\t{\\n\\t\\tx = a + b;\\n\\t\\ty = x + b;\\n\\t}\\n}\\nclass static_use\\n{\\n\\tpublic static void main(String args[])\\n\\t{\\n\\t\\tstatic_out obj1 = new static_out();\\n\\t\\tstatic_out obj2 = new static_out();\\n   \\t\\tint a = 2;\\n\\t\\tobj1.add(a, a + 1);\\n\\t\\tobj2.add(5, a);\\n\\t\\tSystem.out.println(obj1.x + \" \" + obj2.y);\\n\\t}\\n\"}",
            "OPT_A": "7 7",
            "OPT_B": "6 6",
            "OPT_C": "7 9",
            "OPT_D": "9 7",
            "ANSWER": 3
          },
          {
            "Q_ID": 23,
            "Q_TEXT": "Which of these keywords is used to prevent content of a variable from being modified?",
            "Q_PRGM": "",
            "OPT_A": "final",
            "OPT_B": "last",
            "OPT_C": "static",
            "OPT_D": "constant",
            "ANSWER": 1
          },
          {
            "Q_ID": 24,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "class string_class\\n{\\n\\tpublic static void main(String args[])\\n\\t{\\n\\t\\tString obj = \" hello\";\\n\\t\\tString obj1 = \"world\";\\n\\t\\tString obj2 = obj;\\n\\t\\tobj2 = \"world\";\\n\\t\\tSystem.out.println(obj + \" \" + obj2);\\n\\t}\\n}",
            "OPT_A": "hello hello",
            "OPT_B": "Compilation Error",
            "OPT_C": "hello world",
            "OPT_D": "helloworld",
            "ANSWER": 3
          },
          {
            "Q_ID": 25,
            "Q_TEXT": "Which of the following statements are incorrect?",
            "Q_PRGM": "",
            "OPT_A": "String is a class.",
            "OPT_B": "Strings in java are mutable.",
            "OPT_C": "Every string is an object of class String.",
            "OPT_D": "Java defines a peer class of String, called StringBuffer, which allows string to be altered.",
            "ANSWER": 2
          },
          {
            "Q_ID": 26,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "class A \\n{\\n\\tint i;\\n\\tvoid display()\\n\\t{\\n\\t\\tSystem.out.println(i);\\n\\t}\\n}\\nclass B extends A\n{\\n\\tint j;\\n\\tvoid display()\\n\\t{\\n\\t\\tSystem.out.println(j);\\n\\t}\\n}\\nclass inheritance_demo\\n{\\n\\tpublic static void main(String args[])\\n\\t{\\n\\t\\tB obj = new B();\\n\\t\\tobj.i=1;\\n\\t\\tobj.j=2;\\n\\t\\tobj.display();\\n\\t}\\n}",
            "OPT_A": "0",
            "OPT_B": "1",
            "OPT_C": "2",
            "OPT_D": "Compilation Error",
            "ANSWER": 3
          },
          {
            "Q_ID": 27,
            "Q_TEXT": "Which of these operators can be used to get run time information about an object?",
            "Q_PRGM": "",
            "OPT_A": "getInfo",
            "OPT_B": "Info",
            "OPT_C": "instanceof",
            "OPT_D": "getinfoof",
            "ANSWER": 3
          },
          {
            "Q_ID": 28,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "class multithreaded_programing\\n {\\npublic static void main(String args[])\\n\\t{\\n\\t\\tThread t = Thread.currentThread();\\n\\t\\tSystem.out.println(t);\\n\\t}\\n}",
            "OPT_A": "Thread[5,main]",
            "OPT_B": "Thread[main,5]",
            "OPT_C": "Thread[main,0]",
            "OPT_D": "Thread[main,5,main]",
            "ANSWER": 4
          },
          {
            "Q_ID": 29,
            "Q_TEXT": "Which of these are types of multitasking?",
            "Q_PRGM": "",
            "OPT_A": "Process based",
            "OPT_B": "Thread based",
            "OPT_C": "Process and Thread based",
            "OPT_D": "None of the mentioned",
            "ANSWER": 3
          },
          {
            "Q_ID": 30,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "package pkg;\\nclass display\\n {\\n\\tint x;\\n\\tvoid show()\\n\\t{\\n\\t\\tif (x>1)\\n\\t\\t\\tSystem.out.print(x + \" \");\\n\\t}\\n}\\nclass packages\\n{\\n\\tpublicstaticvoidmain(String args[])\\n\\t{\\n\\t\\tdisplay[]arr=newdisplay[3];\\n\\t\\tfor(inti=0;i<3;i++)\\n\\t\\t\\tarr[i]=newdisplay();\\n\\t\\tarr[0].x = 0;\\n\\t\\tarr[1].x = 1;\\n\\t\\tarr[2].x = 2;\\n\\t\\tfor (int i = 0; i <3;++i)\\n\\t\\t\\tarr[i].show();\\n\\t\\t}}\\nNote : packages.class file is in directory pkg;",
            "OPT_A": "0",
            "OPT_B": "1",
            "OPT_C": "2",
            "OPT_D": "0 1 2",
            "ANSWER": 3
          },
          {
            "Q_ID": 31,
            "Q_TEXT": "Which of this access specifies can be used for a class so that its members can be accessed by a different class in the same package?",
            "Q_PRGM": "",
            "OPT_A": "Public",
            "OPT_B": "Protected",
            "OPT_C": "No Modifier",
            "OPT_D": "All of the mentioned",
            "ANSWER": 4
          },
          {
            "Q_ID": 32,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "class newthread implements Runnable\\n {\\n\\tThread t;\\n\\tnewthread()\\n \\t{\\n\\t\\tt = new Thread(this,\"MyThread\");\\n\\t\\tt.start();\\n\\t}\\n\\tpublic void run()\\n \\t{\\n\\t\\tSystem.out.println(t);\\n\\t}\\n}\\nclass multithreaded_programing\\n {\\n\\tpublic static void main(String args[])\\n \\t{\\n\\t\\tnew newthread();\\n\\t}\\n}",
            "OPT_A": "My Thread",
            "OPT_B": "Thread[My Thread,5,main]",
            "OPT_C": "Compilation Error",
            "OPT_D": "Runtime Error",
            "ANSWER": 2
          },
          {
            "Q_ID": 33,
            "Q_TEXT": "What is the default value of priority variable MIN_PRIORITY AND MAX_PRIORITY?",
            "Q_PRGM": "",
            "OPT_A": "0 & 256",
            "OPT_B": "0 & 1",
            "OPT_C": "1 & 10",
            "OPT_D": "1 & 256",
            "ANSWER": 3
          },
          {
            "Q_ID": 34,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "class exception_handling\\n {\\n\\tpublic static void main(String args[])\\n \\t{\\n\\t\\ttry\\t\\t\\t{\\n\\t\\t\\tthrow new NullPointerException(\"Hello\");\\n\\t\\t\\tSystem.out.print(\"A\");\\n\\t\\t}\\n\\t\\tcatch(ArithmeticException e)\\n \\t\\t{\\n\\t\\t\\tSystem.out.print(\"B\");\\n\\t\\t}\\n\\t}\\n}",
            "OPT_A": "A",
            "OPT_B": "B",
            "OPT_C": "Hello",
            "OPT_D": "Runtime Error",
            "ANSWER": 2
          },
          {
            "Q_ID": 35,
            "Q_TEXT": "Which of these handles the exception when no catch is used?",
            "Q_PRGM": "",
            "OPT_A": "Default handler",
            "OPT_B": "finally",
            "OPT_C": "throw handler",
            "OPT_D": "Java run time system",
            "ANSWER": 1
          },
          {
            "Q_ID": 36,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "class exception_handling\\n {\\n\\tpublic static void main(String args[])\\n \\t{\\n\\t\\ttry\\n \\t\\t\\t{\\n\\t\\t\\t\\tSystem.out.print(\"Hello + \" \" + 1 / 0);\\n\\t\\t\\t}\\t\\tcatch(ArithmeticException e)\\n \\t\\t{\\n\\t\\t\\tSystem.out.print(\"World\");\\n\\t\\t}\\n\\t}\\n}",
            "OPT_A": "Hello",
            "OPT_B": "World",
            "OPT_C": "HelloWorld",
            "OPT_D": "Hello World",
            "ANSWER": 2
          },
          {
            "Q_ID": 37,
            "Q_TEXT": "When does Exceptions in Java arises in code sequence?",
            "Q_PRGM": "",
            "OPT_A": "Run Time",
            "OPT_B": "Compilation Time",
            "OPT_C": "Can Occur Any Time",
            "OPT_D": "None of the mentioned",
            "ANSWER": 1
          },
          {
            "Q_ID": 38,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "class recursion\\n{\\n\\tint func (int n)\\n \\t{\\n\\t\\tint result;\\n\\t\\tresult = func (n - 1);\\n\\t\\nreturn result;\\n\\t}\\n}\\n class Output\\n {\\n\\tpublic static void main(String args[])\\n\\t{\\n\\t\\trecursion obj = new recursion() ;\\n\\t\\tSystem.out.print(obj.func(12));\\n\\t}\\n}",
            "OPT_A": "0",
            "OPT_B": "1",
            "OPT_C": "Compilation Error",
            "OPT_D": "Runtime Error",
            "ANSWER": 4
          },
          {
            "Q_ID": 39,
            "Q_TEXT": "Which of these is not abstract?",
            "Q_PRGM": "",
            "OPT_A": "Thread",
            "OPT_B": "AbstractList",
            "OPT_C": "List",
            "OPT_D": "None of the Mentioned",
            "ANSWER": 1
          },
          {
            "Q_ID": 40,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "class A\\n {\\n\\tpublic int i;\\n\\tprivate int j;\\n}\\nclass B extends A\\n{\\n\\tvoid display()\\n \\t{\\n\\t\\tsuper.j = super.i + 1;\\n\\t\\tSystem.out.println(super.i + \"\" + super.j);\\n\\t}\\n}\\n    class inheritance\\n{\\n\\tpublic static void main(String args[])\\n\\t{\\n\\t\\tB obj = new B();\\n\\t\\tobj.i=1;\\n\\t\\tobj.j=2;\\n\\t\\tobj.display();\\n\\t}\\n}",
            "OPT_A": "2 2",
            "OPT_B": "3 3",
            "OPT_C": "Runtime Error",
            "OPT_D": "Compilation Error",
            "ANSWER": 4
          },
          {
            "Q_ID": 41,
            "Q_TEXT": "What is an event in delegation event model used by Java programming language?",
            "Q_PRGM": "",
            "OPT_A": "An event is an object that describes a state change in a source.",
            "OPT_B": "An event is an object that describes a state change in processing.",
            "OPT_C": "An event is an object that describes any change by the user and system.",
            "OPT_D": "An event is a class used for defining object, to create events.",
            "ANSWER": 1
          },
          {
            "Q_ID": 42,
            "Q_TEXT": " Which of these methods are used to register a keyboard event listener?",
            "Q_PRGM": "",
            "OPT_A": "KeyListener()",
            "OPT_B": "addKistener()",
            "OPT_C": "addKeyListener()",
            "OPT_D": "eventKeyboardListener()",
            "ANSWER": 3
          },
          {
            "Q_ID": 43,
            "Q_TEXT": "Event class is defined in which of these libraries?",
            "Q_PRGM": "",
            "OPT_A": "java.io",
            "OPT_B": "java.lang",
            "OPT_C": "java.net",
            "OPT_D": "java.util",
            "ANSWER": 4
          },
          {
            "Q_ID": 44,
            "Q_TEXT": "Which of these methods can be used to determine the type of event?",
            "Q_PRGM": "",
            "OPT_A": "getID()",
            "OPT_B": "getSource()",
            "OPT_C": "getEvent()",
            "OPT_D": "getEventObject()",
            "ANSWER": 1
          },
          {
            "Q_ID": 45,
            "Q_TEXT": "Which of these class is super class of all the events?",
            "Q_PRGM": "",
            "OPT_A": "EventObject",
            "OPT_B": "EventClass",
            "OPT_C": "ActionEvent",
            "OPT_D": "ItemEvent",
            "ANSWER": 1
          },
          {
            "Q_ID": 46,
            "Q_TEXT": "Which of these interfaces define four methods?",
            "Q_PRGM": "",
            "OPT_A": " ComponentListener",
            "OPT_B": "ContainerListener",
            "OPT_C": "ActionListener",
            "OPT_D": "InputListener",
            "ANSWER": 1
          },
          {
            "Q_ID": 47,
            "Q_TEXT": "Which of these is superclass of all Adapter classes?",
            "Q_PRGM": "",
            "OPT_A": "Applet",
            "OPT_B": "ComponentEvent",
            "OPT_C": "Event",
            "OPT_D": "InputEvent",
            "ANSWER": 1
          },
          {
            "Q_ID": 48,
            "Q_TEXT": "Which of these methods can be used to know the type of focus change?",
            "Q_PRGM": "",
            "OPT_A": "typeFocus()",
            "OPT_B": "typeEventFocus()",
            "OPT_C": "isTemporary()",
            "OPT_D": "isPermanent()",
            "ANSWER": 3
          },
          {
            "Q_ID": 49,
            "Q_TEXT": "Which of these events will be notified if scroll bar is manipulated?",
            "Q_PRGM": "",
            "OPT_A": "ActionEvent",
            "OPT_B": "ComponentEvent",
            "OPT_C": "AdjustmentEvent",
            "OPT_D": "WindowEvent",
            "ANSWER": 3
          },
          {
            "Q_ID": 50,
            "Q_TEXT": "Which of these methods can be used to obtain the coordinates of a mouse?",
            "Q_PRGM": "",
            "OPT_A": "getPoint()",
            "OPT_B": "getCoordinates()",
            "OPT_C": "getMouseXY()",
            "OPT_D": "getMouseCordinates()",
            "ANSWER": 1
          },
          {
            "Q_ID": 51,
            "Q_TEXT": "Which of these methods can be used to change location of an event?",
            "Q_PRGM": "",
            "OPT_A": "ChangePoint()",
            "OPT_B": "TranslatePoint()",
            "OPT_C": "ChangeCordinates()",
            "OPT_D": "TranslateCordinates()",
            "ANSWER": 2
          },
          {
            "Q_ID": 52,
            "Q_TEXT": "Which of these are integer constants of TextEvent class?",
            "Q_PRGM": "",
            "OPT_A": "TEXT_CHANGED",
            "OPT_B": "TEXT_FORMAT_CHANGED",
            "OPT_C": "TEXT_VALUE_CHANGED",
            "OPT_D": "TEXT_sIZE_CHANGED",
            "ANSWER": 2
          },
          {
            "Q_ID": 53,
            "Q_TEXT": "MouseEvent is subclass of which of these classes?",
            "Q_PRGM": "",
            "OPT_A": "ComponentEvent",
            "OPT_B": "ContainerEvent",
            "OPT_C": "ItemEvent",
            "OPT_D": "InputEvent",
            "ANSWER": 4
          },
          {
            "Q_ID": 54,
            "Q_TEXT": "Which of these is superclass of WindowEvent class?",
            "Q_PRGM": "",
            "OPT_A": "WindowEvent",
            "OPT_B": "ComponentEvent",
            "OPT_C": "ItemEvent",
            "OPT_D": "InputEvent",
            "ANSWER": 2
          },
          {
            "Q_ID": 55,
            "Q_TEXT": "Which of these methods can be used to obtain the command name for invoking ActionEvent object?",
            "Q_PRGM": "",
            "OPT_A": "getCommand()",
            "OPT_B": "getActionCommand()",
            "OPT_C": "getActionEvent()",
            "OPT_D": "getActionEventCommand()",
            "ANSWER": 2
          }
        ]
      }
    ]
  },
  {
    "CAT_ID": 4,
    "CAT_NAME": "PHP",
    "LEVELS": [
      {
        "LEVEL_ID": 1,
        "LEVEL_NAME": "Practical",
        "LOCK_STATUS": 1,
        "QUESTIONS": [
          {
            "Q_ID" : 1 ,
            "Q_TEXT" : "To Print Integers",
            "Q_PRGM" : "class ForLoop\\n{\\npublic static void main(String[] args)\\n{\\n\\tint c;\\n\\tfor (c = 1; c <= 10; c++)\\n\\t{\\n\\t\\tSystem.out.println(c);\\n\\t}\\n\\t}\\n}",
            "OPT_A" : "1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n10",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          }
        ]
      },
      {
        "LEVEL_ID": 2,
        "LEVEL_NAME": "Theory",
        "LOCK_STATUS": 1,
        "QUESTIONS": [
          {
            "Q_ID" : 1,
            "Q_TEXT" : "Introduction",
            "Q_PRGM" : "PHP is a server scripting language, and a powerful tool for making dynamic and interactive Web pages.\\nPHP is a widely-used, free, and efficient alternative to competitors such as Microsoft's ASP.\\nEasy Learning with \"Show PHP\"\\nOur \"Show PHP\" tool makes it easy to learn PHP, it shows both the PHP source code and the HTML output of the code.\\nExample :\\n<!DOCTYPE html>\\n<html>\\n<body>\\n\\n<?php\\necho \"My first PHP script!\";\\n?>\\n</body>\\n</html>",
            "OPT_A" : "My first PHP script!",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 2,
            "Q_TEXT" : "Array",
            "Q_PRGM" : "The array functions allow you to access and manipulate arrays.\\nSimple and multi-dimensional arrays are supported.\\nPHP Array Functions\\narray() : Creates an array \\narray_change_key_case() : Changes all keys in an array to lowercase or uppercase\\narray_chunk() : Splits an array into chunks of arrays\\narray_column() :  Returns the values from a single column in the input array\\narray_combine() : Creates an array by using the elements from one \"keys\" array and one \"values\" array\\narray_count_values() : Counts all the values of an array\\narray_diff() : Compare arrays, and returns the differences (compare values only)\\narray_diff_assoc() : Compare arrays, and returns the differences (compare keys and values)\\narray_diff_key() : Compare arrays, and returns the differences (compare keys only)\\narray_diff_uassoc() : Compare arrays, and returns the differences (compare keys and values, using a user-defined key comparison function)\\narray_diff_ukey() : Compare arrays, and returns the differences (compare keys only, using a user-defined key comparison function)\\narray_fill() : Fills an array with values\\narray_fill_keys() : Fills an array with values, specifying keys\\narray_filter() : Filters the values of an array using a callback function\\narray_flip() : Flips/Exchanges all keys with their associated values in an array\\narray_intersect() : Compare arrays, and returns the matches (compare values only)\\narray_intersect_assoc() : Compare arrays and returns the matches (compare keys and values)\\narray_intersect_key() : Compare arrays, and returns the matches (compare keys only)\\narray_intersect_uassoc() : Compare arrays, and returns the matches (compare keys and values, using a user-defined key comparison function)\\narray_intersect_ukey() :  Compare arrays, and returns the matches (compare keys only, using a user-defined key comparison function)\\narray_key_exists() :  Checks if the specified key exists in the array\\narray_keys() : Returns all the keys of an array\\narray_map() : Sends each value of an array to a user-made function, which returns new values\\narray_merge() : Merges one or more arrays into one array\\narray_merge_recursive() : Merges one or more arrays into one array recursively\\narray_multisort() : Sorts multiple or multi-dimensional arrays\\narray_pad() : Inserts a specified number of items, with a specified value, to an array\\narray_pop() : Deletes the last element of an array\\narray_product() : Calculates the product of the values in an array\\narray_push() : Inserts one or more elements to the end of an array\\narray_rand() : Returns one or more random keys from an array\\narray_reduce() : Returns an array as a string, using a user-defined function\\narray_replace() : Replaces the values of the first array with the values from following arrays\\narray_replace_recursive() : Replaces the values of the first array with the values from following arrays recursively\\narray_reverse() : Returns an array in the reverse order\\narray_search() : Searches an array for a given value and returns the key\\narray_shift() : Removes the first element from an array, and returns the value of the removed element\\narray_slice() : Returns selected parts of an array\\narray_splice() : Removes and replaces specified elements of an array\\narray_sum() : Returns the sum of the values in an array\\narray_udiff() : Compare arrays, and returns the differences (compare values only, using a user-defined key comparison function)\\narray_udiff_assoc() : Compare arrays, and returns the differences (compare keys and values, using a built-in function to compare the keys and a user-defined function to compare the values)\\narray_udiff_uassoc() : Compare arrays, and returns the differences (compare keys and values, using two user-defined key comparison functions)\\narray_uintersect() : Compare arrays, and returns the matches (compare values only, using a user-defined key comparison function)\\narray_uintersect_assoc() : Compare arrays, and returns the matches (compare keys and values, using a built-in function to compare the keys and a user-defined function to compare the values)\\narray_uintersect_uassoc() : Compare arrays, and returns the matches (compare keys and values, using two user-defined key comparison functions)\\narray_unique() : Removes duplicate values from an array\\narray_unshift() : Adds one or more elements to the beginning of an array\\narray_values() : Returns all the values of an array\\narray_walk() : Applies a user function to every member of an array\\narray_walk_recursive() : Applies a user function recursively to every member of an array\\narsort() : Sorts an associative array in descending order, according to the value\\nasort() : Sorts an associative array in ascending order, according to the value\\ncompact() : Create array containing variables and their values\\ncount() : Returns the number of elements in an array\\ncurrent() : Returns the current element in an array\\neach() : Returns the current key and value pair from an array\\nend() : Sets the internal pointer of an array to its last element\\nextract() : Imports variables into the current symbol table from an array\\nin_array() : Checks if a specified value exists in an array\\nkey() : Fetches a key from an array\\nkrsort() : Sorts an associative array in descending order, according to the key\\nksort() : Sorts an associative array in ascending order, according to the key\\nlist() : Assigns variables as if they were an array\\nnatcasesort() : Sorts an array using a case insensitive \"natural order\" algorithm\\nnatsort() : Sorts an array using a \"natural order\" algorithm\\nnext() : Advance the internal array pointer of an array\\npos() : Alias of current()\\nprev() : Rewinds the internal array pointer\\nrange() : Creates an array containing a range of elements\\nreset() : Sets the internal pointer of an array to its first element\\nrsort() : Sorts an indexed array in descending order\\nshuffle() : Shuffles an array\\nsizeof() : Alias of count()\\nsort() : Sorts an indexed array in ascending order\\nuasort() : Sorts an array by values using a user-defined comparison function\\nuksort() : Sorts an array by keys using a user-defined comparison function\\nusort() : Sorts an array using a user-defined comparison function",
            "OPT_A" : "No installation required for these functions.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1
          },
          {
            "Q_ID" : 3,
            "Q_TEXT" : "Calendar",
            "Q_PRGM" : "The calendar extension contains functions that simplifies converting between different calendar formats.\\nIt is based on the Julian Day Count, which is a count of days starting from January 1st, 4713 B.C.\\n\\nCalendar Functions\\ncal_info() : Returns information about a specified calendar\\ncal_to_jd() : Converts a date in a specified calendar to Julian Day Count\\neaster_date() : Returns the Unix timestamp for midnight on Easter of a specified year\\neaster_days() : Returns the number of days after March 21, that the Easter Day is in a specified year\\nfrenchtojd() : Converts a French Republican date to a Julian Day Count\\ngregoriantojd() : Converts a Gregorian date to a Julian Day Count\\njddayofweek() : Returns the day of the week",
            "OPT_A" : "To convert between calendar formats, you must first convert to Julian Day Count, then to the calendar of your choice.\\nThe Julian Day Count is not the same as the Julian Calendar!",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 4,
            "Q_TEXT" : "Date/Time Functions",
            "Q_PRGM" : "The date/time functions allow you to get the date and time from the server where your PHP script runs. You can then use the date/time functions to format the date and time in several ways.\\n\\ncheckdate() : Validates a Gregorian date\\ndate_add() : Adds days, months, years, hours, minutes, and seconds to a date\\ndate_create_from_format() : Returns a new DateTime object formatted according to a specified format\\ndate_create() : Returns a new DateTime object\\ndate_date_set() : Sets a new date\\ndate_default_timezone_get() : Returns the default timezone used by all date/time functions\\ndate_default_timezone_set() : Sets the default timezone used by all date/time functions\\ndate_diff() : Returns the difference between two dates\nndate_format() : Returns a date formatted according to a specified format",            "OPT_A" : "These functions depend on the locale settings of your server. Remember to take daylight saving time and leap years into consideration when working with these functions.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 5,
            "Q_TEXT" : "Directory Functions",
            "Q_PRGM" : "The directory functions allow you to retrieve information about directories and their contents.\\nchdir() : Changes the current directory\\nchroot() : Changes the root directory\\nclosedir() : Closes a directory handle\\ndir() : Returns an instance of the Directory class\\ngetcwd() : Returns the current working directory\\nopendir() : Opens a directory handle\\nreaddir() : Returns an entry from a directory handle\\nrewinddir() : Resets a directory handle\\nscandir() : Returns an array of files and directories of a specified directory",            "OPT_A" : "No installation is required to use these functions.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 6,
            "Q_TEXT" : "Implementations",
            "Q_PRGM" : "Oracle Corporation is the current owner of the official implementation of the Java SE platform, following their acquisition of Sun Microsystems on January 27, 2010. This implementation is based on the original implementation of Java by Sun. The Oracle implementation is available for Microsoft Windows (still works for XP, while only later versions currently \"publicly\" supported), Mac OS X, Linux and Solaris. Because Java lacks any formal standardization recognized by Ecma International, ISO/IEC, ANSI, or other third-party standards organization, the Oracle implementation is the de facto standard.\\nThe Oracle implementation is packaged into two different distributions: The Java Runtime Environment (JRE) which contains the parts of the Java SE platform required to run Java programs and is intended for end users, and the Java Development Kit (JDK), which is intended for software developers and includes development tools such as the Java compiler, Javadoc, Jar, and a debugger.\\nOpenJDK is another notable Java SE implementation that is licensed under the GNU GPL. The implementation started when Sun began releasing the Java source code under the GPL. As of Java SE 7, OpenJDK is the official Java reference implementation.\\nThe goal of Java is to make all implementations of Java compatible. Historically, Sun's trademark license for usage of the Java brand insists that all implementations be \"compatible\". This resulted in a legal dispute with Microsoft after Sun claimed that the Microsoft implementation did not support RMI or JNI and had added platform-specific features of their own. Sun sued in 1997, and in 2001 won a settlement of US$20 million, as well as a court order enforcing the terms of the license from Sun. As a result, Microsoft no longer ships Java with Windows.\\nPlatform-independent Java is essential to Java EE, and an even more rigorous validation is required to certify an implementation. This environment enables portable server-side applications.",
            "OPT_A" : "The Oracle implementation is packaged into two different distributions: The Java Runtime Environment (JRE) which contains the parts of the Java SE platform required to run Java programs and is intended for end users, and the Java Development Kit (JDK), which is intended for software developers and includes development tools such as the Java compiler, Javadoc, Jar, and a debugger.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 7,
            "Q_TEXT" : "Performance",
            "Q_PRGM" : "Programs written in Java have a reputation for being slower and requiring more memory than those written in C++. However, Java programs' execution speed improved significantly with the introduction of just-in-time compilation in 1997/1998 for Java 1.1, the addition of language features supporting better code analysis (such as inner classes, the StringBuilder class, optional assertions, etc.), and optimizations in the Java virtual machine, such as HotSpot becoming the default for Sun's JVM in 2000.\\nSome platforms offer direct hardware support for Java; there are microcontrollers that can run Java in hardware instead of a software Java virtual machine, and ARM based processors can have hardware support for executing Java bytecode through their Jazelle option (while its support is mostly dropped in current implementations of ARM).",
            "OPT_A" : "Some platforms offer direct hardware support for Java; there are microcontrollers that can run Java in hardware instead of a software Java virtual machine",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 8,
            "Q_TEXT" : "Automatic memory management",
            "Q_PRGM" : "Java uses an automatic garbage collector to manage memory in the object lifecycle. The programmer determines when objects are created, and the Java runtime is responsible for recovering the memory once objects are no longer in use. Once no references to an object remain, the unreachable memory becomes eligible to be freed automatically by the garbage collector. Something similar to a memory leak may still occur if a programmer's code holds a reference to an object that is no longer needed, typically when objects that are no longer needed are stored in containers that are still in use. If methods for a nonexistent object are called, a \"null pointer exception\" is thrown.\\nOne of the ideas behind Java's automatic memory management model is that programmers can be spared the burden of having to perform manual memory management. In some languages, memory for the creation of objects is implicitly allocated on the stack, or explicitly allocated and deallocated from the heap. In the latter case the responsibility of managing memory resides with the programmer. If the program does not deallocate an object, a memory leak occurs. If the program attempts to access or deallocate memory that has already been deallocated, the result is undefined and difficult to predict, and the program is likely to become unstable and/or crash. This can be partially remedied by the use of smart pointers, but these add overhead and complexity. Note that garbage collection does not prevent \"logical\" memory leaks, i.e., those where the memory is still referenced but never used.\\nGarbage collection may happen at any time. Ideally, it will occur when a program is idle. It is guaranteed to be triggered if there is insufficient free memory on the heap to allocate a new object; this can cause a program to stall momentarily. Explicit memory management is not possible in Java.\\nJava does not support C/C++ style pointer arithmetic, where object addresses and unsigned integers (usually long integers) can be used interchangeably. This allows the garbage collector to relocate referenced objects and ensures type safety and security.\\nAs in C++ and some other object-oriented languages, variables of Java's primitive data types are either stored directly in fields (for objects) or on the stack (for methods) rather than on the heap, as is commonly true for non-primitive data types (but see escape analysis). This was a conscious decision by Java's designers for performance reasons.\\nJava contains multiple types of garbage collectors. By default, HotSpot uses the parallel scavenge garbage collector. However, there are also several other garbage collectors that can be used to manage the heap. For 90% of applications in Java, the Concurrent Mark-Sweep garbage collector is sufficient. Oracle aims to replace CMS with the Garbage-first collector (G1).",
            "OPT_A" : "Java does not support C/C++ style pointer arithmetic",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 9,
            "Q_TEXT" : "Syntax",
            "Q_PRGM" : "The syntax of Java is largely influenced by C++. Unlike C++, which combines the syntax for structured, generic, and object-oriented programming, Java was built almost exclusively as an object-oriented language. All code is written inside classes, and every data item is an object, with the exception of the primitive data types, i.e. integers, floating-point numbers, boolean values, and characters, which are not objects for performance reasons. Java reuses some popular aspects of C++ (such as printf() method).\\nUnlike C++, Java does not support operator overloading or multiple inheritance for classes, though multiple inheritance is supported for interfaces. This simplifies the language and aids in preventing potential errors and anti-pattern design.\\nJava uses comments similar to those of C++. There are three different styles of comments: a single line style marked with two slashes (//), a multiple line style opened with /*and closed with */, and the Javadoc commenting style opened with /** and closed with */. The Javadoc style of commenting allows the user to run the Javadoc executable to create documentation for the program.",
            "OPT_A" : "Unlike C++, Java does not support operator overloading or multiple inheritance for classes",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 10,
            "Q_TEXT" : "Syntax",
            "Q_PRGM" : "The syntax of Java is largely influenced by C++. Unlike C++, which combines the syntax for structured, generic, and object-oriented programming, Java was built almost exclusively as an object-oriented language. All code is written inside classes, and every data item is an object, with the exception of the primitive data types, i.e. integers, floating-point numbers, boolean values, and characters, which are not objects for performance reasons. Java reuses some popular aspects of C++ (such as printf() method).\\nUnlike C++, Java does not support operator overloading or multiple inheritance for classes, though multiple inheritance is supported for interfaces. This simplifies the language and aids in preventing potential errors and anti-pattern design.\\nJava uses comments similar to those of C++. There are three different styles of comments: a single line style marked with two slashes (//), a multiple line style opened with /*and closed with */, and the Javadoc commenting style opened with /** and closed with */. The Javadoc style of commenting allows the user to run the Javadoc executable to create documentation for the program.Source files must be named after the public class they contain, appending the suffix .java, for example, HelloWorldApp.java. It must first be compiled into bytecode, using aJava compiler, producing a file named HelloWorldApp.class. Only then can it be executed, or \"launched\". The Java source file may only contain one public class, but it can contain multiple classes with other than public access and any number of public inner classes. When the source file contains multiple classes, make one class \"public\" and name the source file with that public class name.\\nA class that is not declared public may be stored in any .java file. The compiler will generate a class file for each class defined in the source file. The name of the class file is the name of the class, with .class appended. For class file generation, anonymous classes are treated as if their name were the concatenation of the name of their enclosing class, a $, and an integer.\\nThe keyword public denotes that a method can be called from code in other classes, or that a class may be used by classes outside the class hierarchy. The class hierarchy is related to the name of the directory in which the .java file is located. This is called an access level modifier. Other access level modifiers include the keywords private , andprotected.\\nThe keyword static in front of a method indicates a static method, which is associated only with the class and not with any specific instance of that class. Only static methods can be invoked without a reference to an object. Static methods cannot access any class members that are not also static. Methods that are not designated static are instance methods, and require a specific instance of a class to operate.\\nThe keyword void indicates that the main method does not return any value to the caller. If a Java program is to exit with an error code, it must call System.exit() explicitly.\\nThe method name \"main\" is not a keyword in the Java language. It is simply the name of the method the Java launcher calls to pass control to the program. Java classes that run in managed environments such as applets and Enterprise JavaBeans do not use or need a main() method. A Java program may contain multiple classes that have mainmethods, which means that the VM needs to be explicitly told which class to launch from.\\nThe main method must accept an array of String objects. By convention, it is referenced as args although any other legal identifier name can be used. Since Java 5, the main method can also use variable arguments, in the form of public static void main(String... args), allowing the main method to be invoked with an arbitrary number of String arguments. The effect of this alternate declaration is semantically identical (the args parameter is still an array of String objects), but it allows an alternative syntax for creating and passing the array.\\nThe Java launcher launches Java by loading a given class (specified on the command line or as an attribute in a JAR) and starting its public static void main(String[])method. Stand-alone programs must declare this method explicitly. The String[] args parameter is an array of String objects containing any arguments passed to the class. The parameters to main are often passed by means of a command line.\\nPrinting is part of a Java standard library: The System class defines a public static field called out. The out object is an instance of the PrintStream class and provides many methods for printing data to standard out, including println(String) which also appends a new line to the passed string.\\nThe string \"Hello World!\" is automatically converted to a String object by the compiler.",
            "OPT_A" : "Unlike C++, Java does not support operator overloading or multiple inheritance for classes",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 11,
            "Q_TEXT" : "Applet",
            "Q_PRGM" : "Java applets are programs that are embedded in other applications, typically in a Web page displayed in a web browser.The import statements direct the Java compiler to include the javax.swing.JApplet and java.awt.Graphics classes in the compilation. The import statement allows these classes to be referenced in the source code using the simple class name (i.e. JApplet) instead of the fully qualified class name (FQCN, i.e. javax.swing.JApplet).\\nThe Hello class extends (subclasses) the JApplet (Java Applet) class; the JApplet class provides the framework for the host application to display and control thelifecycle of the applet. The JApplet class is a JComponent (Java Graphical Component) which provides the applet with the capability to display a graphical user interface (GUI) and respond to user events.\\nThe Hello class overrides the paintComponent(Graphics) method (additionally indicated with the annotation, supported as of JDK 1.5, Override) inherited from theContainer superclass to provide the code to display the applet. The paintComponent() method is passed a Graphics object that contains the graphic context used to display the applet. The paintComponent() method calls the graphic context drawString(String, int, int) method to display the \"Hello, world!\" string at a pixel offset of (65, 95) from the upper-left corner in the applet's display.\\nAn applet is placed in an HTML document using the <applet> HTML element. The applet tag has three attributes set: code=\"Hello\" specifies the name of the JAppletclass and width=\"200\" height=\"200\" sets the pixel width and height of the applet. Applets may also be embedded in HTML using either the object or embed element,although support for these elements by web browsers is inconsistent. However, the applet tag is deprecated, so the object tag is preferred where supported.\\nThe host application, typically a Web browser, instantiates the Hello applet and creates an AppletContext for the applet. Once the applet has initialized itself, it is added to the AWT display hierarchy. The paintComponent() method is called by the AWT event dispatching thread whenever the display needs the applet to draw itself.",
            "OPT_A" : "The JApplet class provides the framework for the host application to display and control the lifecycle of the applet. ",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 12,
            "Q_TEXT" : "Servlet",
            "Q_PRGM" : "Java Servlet technology provides Web developers with a simple, consistent mechanism for extending the functionality of a Web server and for accessing existing business systems. Servlets are server-side Java EE components that generate responses (typically HTML pages) to requests (typically HTTP requests) from clients. A servlet can almost be thought of as an applet that runs on the server side—without a face.\\nThe import statements direct the Java compiler to include all the public classes and interfaces from the java.io and javax.servlet packages in the compilation. Packages make Java well suited for large scale applications.\\nThe Hello class extends the GenericServlet class; the GenericServlet class provides the interface for the server to forward requests to the servlet and control the servlet's lifecycle.\\nThe Hello class overrides the service(ServletRequest, ServletResponse) method defined by the Servlet interface to provide the code for the service request handler. The service() method is passed: a ServletRequest object that contains the request from the client and a ServletResponse object used to create the response returned to the client. The service() method declares that it throws the exceptions ServletException and IOException if a problem prevents it from responding to the request.\\nThe setContentType(String) method in the response object is called to set the MIME content type of the returned data to \"text/html\". The getWriter() method in the response returns a PrintWriter object that is used to write the data that is sent to the client. The println(String) method is called to write the \"Hello, world!\" string to the response and then the close() method is called to close the print writer, which causes the data that has been written to the stream to be returned to the client.",
            "OPT_A" : "A servlet can almost be thought of as an applet that runs on the server side—without a face.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 13,
            "Q_TEXT" : "JavaServer Pages",
            "Q_PRGM" : "JavaServer Pages (JSP) are server-side Java EE components that generate responses, typically HTML pages, to HTTP requests from clients. JSPs embed Java code in an HTML page by using the special delimiters <% and %>. A JSP is compiled to a Java servlet, a Java application in its own right, the first time it is accessed. After that, the generated servlet creates the response.",
            "OPT_A" : "JSP consists of both html tags and also tha java code encoporated within <% and %>",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 14,
            "Q_TEXT" : "Swing application",
            "Q_PRGM" : "Swing is a graphical user interface library for the Java SE platform. It is possible to specify a different look and feel through the pluggable look and feel system of Swing. Clones ofWindows, GTK+ and Motif are supplied by Sun. Apple also provides an Aqua look and feel for Mac OS X. Where prior implementations of these looks and feels may have been considered lacking, Swing in Java SE 6 addresses this problem by using more native GUI widget drawing routines of the underlying platforms.\\nThe import includes all the public classes and interfaces from the javax.swing package.\\nThe Hello class extends the JFrame class; the JFrame class implements a window with a title bar and a close control.\\nThe Hello() constructor initializes the frame by first calling the superclass constructor, passing the parameter \"hello\", which is used as the window's title. It then calls thesetDefaultCloseOperation(int) method inherited from JFrame to set the default operation when the close control on the title bar is selected toWindowConstants.EXIT_ON_CLOSE – this causes the JFrame to be disposed of when the frame is closed (as opposed to merely hidden), which allows the Java virtual machine to exit and the program to terminate. Next, a JLabel is created for the string \"Hello, world!\" and the add(Component) method inherited from the Containersuperclass is called to add the label to the frame. The pack() method inherited from the Window superclass is called to size the window and lay out its contents.\\nThe main() method is called by the Java virtual machine when the program starts. It instantiates a new Hello frame and causes it to be displayed by calling thesetVisible(boolean) method inherited from the Component superclass with the boolean parameter true. Once the frame is displayed, exiting the main method does not cause the program to terminate.",
            "OPT_A" : "AWT event dispatching thread remains active until all of the Swing top-level windows have been disposed.",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          },
          {
            "Q_ID" : 15,
            "Q_TEXT" : "Generics",
            "Q_PRGM" : "In 2004, generics were added to the Java language, as part of J2SE 5.0. Prior to the introduction of generics, each variable declaration had to be of a specific type. For container classes, for example, this is a problem because there is no easy way to create a container that accepts only specific types of objects. Either the container operates on all subtypes of a class or interface, usually Object, or a different container class has to be created for each contained class. Generics allow compile-time type checking without having to create many container classes, each containing almost identical code. In addition to enabling more efficient code, certain runtime exceptions are converted to compile-time errors, a characteristic known as type safety.",
            "OPT_A" : "Either the container operates on all subtypes of a class or interface, usually Object, or a different container class has to be created for each contained class",
            "OPT_B" : "A",
            "OPT_C" : "A",
            "OPT_D" : "A",
            "ANSWER" : 1

          }
        ]
      },
      {
        "LEVEL_ID": 3,
        "LEVEL_NAME": "Miscellaneous",
        "LOCK_STATUS": 1,
        "QUESTIONS": [
          {
            "Q_ID": 1,
            "Q_TEXT": "What does PHP stand for?",
            "Q_PRGM": "",
            "OPT_A": "Procces Html Page",
            "OPT_B": "Hypertext Preprocessor",
            "OPT_C": "Pretext Hypertext Processor",
            "OPT_D": "Postprocessor Home Page",
            "ANSWER": 2
          },
          {
            "Q_ID": 2,
            "Q_TEXT": "A PHP script should start with ___ and end with ___",
            "Q_PRGM": "",
            "OPT_A": "< php >",
            "OPT_B": "< ? php ?>",
            "OPT_C": "<? ?>",
            "OPT_D": "<?php ?>",
            "ANSWER": 4
          },
          {
            "Q_ID": 3,
            "Q_TEXT": "Which version of PHP introduced Try/catch Exception?",
            "Q_PRGM": "",
            "OPT_A": "PHP 2",
            "OPT_B": "PHP 3",
            "OPT_C": "PHP 4",
            "OPT_D": "PHP 5.x",
            "ANSWER": 4
          },
          {
            "Q_ID": 4,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "<?php\\n\\t$num  = 1;\\n\\t$num1 = 2;\\n\\tprint $num . \"+\". $num1;\\n?>",
            "OPT_A": "3",
            "OPT_B": "1+2",
            "OPT_C": "1.+.2",
            "OPT_D": "Error",
            "ANSWER": 2
          },
          {
            "Q_ID": 5,
            "Q_TEXT": "What will be the output of the following PHP code?",
            "Q_PRGM": "<?php\\n\\tfunction calc($price, $tax=\"\")\\n\\t{\\n\\t\\t$total = $price + ($price * $tax);\\n\\t\\techo \"$total\"; \\n\\t}\\n\\tcalc(42); \\n?>",
            "OPT_A": "Error",
            "OPT_B": "0",
            "OPT_C": "42",
            "OPT_D": "84",
            "ANSWER": 3
          },
          {
            "Q_ID": 6,
            "Q_TEXT": " What will be the output of the following PHP code ?",
            "Q_PRGM": "<?php\\n$city_west = array(\"NYC\", \"London\");\\n$city_east = array(\"Mumbai\", \"Beijing\");\\nprint_r(array_replace($city_west, $city_east));\\n?>",
            "OPT_A": "Array ( [1] => Mumbai [0] => Beijing )",
            "OPT_B": "Array ( [0] => NYC [1] => London )",
            "OPT_C": "Array ( [1] => NYC [0] => London )",
            "OPT_D": "Array ( [0] => Mumbai [1] => Beijing )",
            "ANSWER": 4
          },
          {
            "Q_ID": 7,
            "Q_TEXT": "Which one of the following can be used to instantiate an object in PHP assuming class name to be Foo?",
            "Q_PRGM": "",
            "OPT_A": "$obj = new $foo;",
            "OPT_B": "$obj = new foo;",
            "OPT_C": "$obj = new foo ();",
            "OPT_D": "obj = new foo ();",
            "ANSWER": 3
          },
          {
            "Q_ID": 8,
            "Q_TEXT": "PHP recognizes constructors by the name.",
            "Q_PRGM": "",
            "OPT_A": "classname()",
            "OPT_B": "_construct()",
            "OPT_C": "function _construct()",
            "OPT_D": "function __construct()",
            "ANSWER": 4
          },
          {
            "Q_ID": 9,
            "Q_TEXT": "How many error levels are available in PHP?",
            "Q_PRGM": "",
            "OPT_A": "14",
            "OPT_B": "15",
            "OPT_C": "16",
            "OPT_D": "17",
            "ANSWER": 3
          },
          {
            "Q_ID": 10,
            "Q_TEXT": "Say you want to report error concerned about fatal run-time, fatal compile-time error and core error which statement would you use?",
            "Q_PRGM": "",
            "OPT_A": "error_reporting = E_ALL",
            "OPT_B": "error_reporting = E_ERROR | E_PARSE | E_CORE_ERROR",
            "OPT_C": "error_reporting = E_ERROR | E_COMPILE_WARNING | E_CORE_ERROR",
            "OPT_D": "error_reporting = E_ERROR | E_COMPILE_ERROR | E_CORE_ERROR",
            "ANSWER": 4
          },
          {
            "Q_ID": 11,
            "Q_TEXT": "Which of the following statements invoke the exception class?",
            "Q_PRGM": "",
            "OPT_A": "throws new Exception();",
            "OPT_B": "throw new Exception();",
            "OPT_C": "new Exception();",
            "OPT_D": "new throws Exception();",
            "ANSWER": 2
          },
          {
            "Q_ID": 12,
            "Q_TEXT": "Which one of the following is the right description for the method getMessage() ?",
            "Q_PRGM": "",
            "OPT_A": "Returns the message if it is passed to the constructor.",
            "OPT_B": "Returns the message if it is passed to the class.",
            "OPT_C": "Returns the message if it is passed to the file.",
            "OPT_D": "Returns the message if it is passed to the object.",
            "ANSWER": 1
          },
          {
            "Q_ID": 13,
            "Q_TEXT": "What will be the output of the following PHP code?",
            "Q_PRGM": "<?php\\n$value = 'car';\\n$result = filter_var($value, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE);\\n?>",
            "OPT_A": "FALSE",
            "OPT_B": "TRUE",
            "OPT_C": "NULL",
            "OPT_D": "ERROR",
            "ANSWER": 3
          },
          {
            "Q_ID": 14,
            "Q_TEXT": "PHP has long supported two regular expression implementations known as ___  and _____",
            "Q_PRGM": "",
            "OPT_A": "PEAR",
            "OPT_B": "PEARL",
            "OPT_C": "POSTGRES",
            "OPT_D": "PERL",
            "ANSWER": 4
          },
          {
            "Q_ID": 15,
            "Q_TEXT": "[:alpha:] can also be specified as _____",
            "Q_PRGM": "",
            "OPT_A": "[A-Za-z0-9]",
            "OPT_B": "[A-za-z]",
            "OPT_C": "[A-z]",
            "OPT_D": "[a-z]",
            "ANSWER": 2
          },
          {
            "Q_ID": 16,
            "Q_TEXT": "What is the output of this program?",
            "Q_PRGM": "<?php\\n\\t$text = \"this is\\\tsome text that\\\nwe might like to parse.\";\\nprint_r(split(\"[\n\t]\",$text));\\n?>",
            "OPT_A": "this is some text that we might like to parse",
            "OPT_B": "Array ( [0] => some text that [1] => we might like to parse. )",
            "OPT_C": "Array ( [0] => this is [1] => some text that [2] => we might like to parse. )",
            "OPT_D": "[0] => this is [1] => some text that [2] => we might like to parse.",
            "ANSWER": 4
          },
          {
            "Q_ID": 17,
            "Q_TEXT": "Which one of the following function outputs the contents of a string variable to the specified resource?",
            "Q_PRGM": "",
            "OPT_A": "filewrite()",
            "OPT_B": "fwrite()",
            "OPT_C": "filewrites()",
            "OPT_D": "fwrites()",
            "ANSWER": 2
          },
          {
            "Q_ID": 18,
            "Q_TEXT": "The updated MySQL extension released with PHP 5 is typically referred to as",
            "Q_PRGM": "",
            "OPT_A": "MySQL",
            "OPT_B": "mysql",
            "OPT_C": "mysqli",
            "OPT_D": "mysqly",
            "ANSWER": 3
          },
          {
            "Q_ID": 19,
            "Q_TEXT": "Which method returns the error code generated from the execution of the last MySQL function?",
            "Q_PRGM": "",
            "OPT_A": "errno()",
            "OPT_B": "errnumber()",
            "OPT_C": "errorno()",
            "OPT_D": "errornumber()",
            "ANSWER": 1
          },
          {
            "Q_ID": 20,
            "Q_TEXT": "Which one of the following method is used to retrieve the number of rows affected by an INSERT, UPDATE, or DELETE query?",
            "Q_PRGM": "",
            "OPT_A": "num_rows()",
            "OPT_B": "affected_rows()",
            "OPT_C": "changed_rows()",
            "OPT_D": "new_rows()",
            "ANSWER": 2
          },
          {
            "Q_ID": 21,
            "Q_TEXT": "Which method rolls back the present transaction?",
            "Q_PRGM": "",
            "OPT_A": "commit()",
            "OPT_B": "undo()",
            "OPT_C": "back()",
            "OPT_D": "rollback()",
            "ANSWER": 1
          },
          {
            "Q_ID": 22,
            "Q_TEXT": "Which symbol is used to declare nested namespaces?",
            "Q_PRGM": "",
            "OPT_A": "/",
            "OPT_B": "\\",
            "OPT_C": ".",
            "OPT_D": "|",
            "ANSWER": 2
          },
          {
            "Q_ID": 23,
            "Q_TEXT": "Which one of the following statements is true for require() and require_once()?",
            "Q_PRGM": "",
            "OPT_A": "They are functions.",
            "OPT_B": "They are statements.",
            "OPT_C": "They’ll not work if the () is not present.",
            "OPT_D": "They can not be used to require files.",
            "ANSWER": 2
          },
          {
            "Q_ID": 24,
            "Q_TEXT": "What will be the output of the following PHP code ?",
            "Q_PRGM": "<?php\\ndefine(\"__LINE__\", \"PHP is a scripting language\");\\necho __LINE__;\\n?>",
            "OPT_A": "PHP is a scripting language",
            "OPT_B": "__LINE__",
            "OPT_C": "2",
            "OPT_D": "ERROR",
            "ANSWER": 3
          },
          {
            "Q_ID": 25,
            "Q_TEXT": "What will be the output of the following PHP code ?",
            "Q_PRGM": "<?php\\n$i = 0;\\nwhile ($i = 10)\\n{\\n\\tprint \"hi\";\\n}\\nprint \"hello\";\\n?>",
            "OPT_A": "hello",
            "OPT_B": "infinite loop",
            "OPT_C": "hihello",
            "OPT_D": "error",
            "ANSWER": 2
          },
          {
            "Q_ID": 26,
            "Q_TEXT": "What will be the output of the following PHP code ?",
            "Q_PRGM": "<?php\\n$i = 5;\\nwhile (--$i > 0 && ++$i)\\n{\\n\\tprint $i;\\n}\\n?>",         
            "OPT_A": "5",
            "OPT_B": "555...infinity",
            "OPT_C": "54321",
            "OPT_D": "error",
            "ANSWER": 2
          },
          {
            "Q_ID": 27,
            "Q_TEXT": "Which one of the following function is used to return an array consisting of various DNS resource records pertinent to a specific domain?",
            "Q_PRGM": "",
            "OPT_A": "dns_get_record()",
            "OPT_B": "dns_record()",
            "OPT_C": "dnsrr_get_record()",
            "OPT_D": "dnsrr_record()",
            "ANSWER": 1
          },
          {
            "Q_ID": 28,
            "Q_TEXT": "Which one of the following is the default PHP session name?",
            "Q_PRGM": "",
            "OPT_A": "PHPSESSID",
            "OPT_B": "PHPSESID",
            "OPT_C": "PHPSESSIONID",
            "OPT_D": "PHPIDSESS",
            "ANSWER": 1
          },
          {
            "Q_ID": 29,
            "Q_TEXT": "What is the default time(in seconds) for which session data is considered valid?",
            "Q_PRGM": "",
            "OPT_A": "1800",
            "OPT_B": "3600",
            "OPT_C": "1440",
            "OPT_D": "1540",
            "ANSWER": 3
          },
          {
            "Q_ID": 30,
            "Q_TEXT": "Which one of the following function is used to start a session?",
            "Q_PRGM": "",
            "OPT_A": "start_session()",
            "OPT_B": "session_start()",
            "OPT_C": "session_begin()",
            "OPT_D": "begin_session()",
            "ANSWER": 2
          },
          {
            "Q_ID": 31,
            "Q_TEXT": "The memory_limit is only applicable if ___ is enabled when you configure PHP. Fill in the blank.",
            "Q_PRGM": "",
            "OPT_A": "–enable-limit",
            "OPT_B": "-enable-memory-limit",
            "OPT_C": "--enable-memory-limit",
            "OPT_D": "-memory-limit",
            "ANSWER": 3
          },
          {
            "Q_ID": 32,
            "Q_TEXT": " What will be the output of the following code? If say date is 22/06/2013.",
            "Q_PRGM": "<?php\\necho \"Today is \".date(\"F d, Y\")\\n?>",
            "OPT_A": "Today is 22 June, 2013",
            "OPT_B": "Today is 22-06-2013",
            "OPT_C": "Today is 06-22-2013",
            "OPT_D": "Today is June 22, 2013",
            "ANSWER": 4
          },
          {
            "Q_ID": 33,
            "Q_TEXT": "Which function displays the web page’s most recent modification date?",
            "Q_PRGM": "",
            "OPT_A": "lastmod()",
            "OPT_B": "getlastmod()",
            "OPT_C": "last_mod()",
            "OPT_D": "get_last_mod()",
            "ANSWER": 2
          },
          {
            "Q_ID": 34,
            "Q_TEXT": "To create an object and set the date to JUNE 22, 2013, which one of the following statement should be executed?",
            "Q_PRGM": "",
            "OPT_A": "$date = Date(\"22 JUNE 2013\")",
            "OPT_B": "$date = new Date(\"JUNE 22 2013\")",
            "OPT_C": "$date = DateTime(\"22 JUNE 2013\")",
            "OPT_D": "$date = new DateTime(\"22 JUNE 2013\")",
            "ANSWER": 4
          },
          {
            "Q_ID": 35,
            "Q_TEXT": "Which function is used to verify whether a variable contains a value?",
            "Q_PRGM": "",
            "OPT_A": "contains()",
            "OPT_B": "header()",
            "OPT_C": "inset()",
            "OPT_D": "isset()",
            "ANSWER": 4
          },
          {
            "Q_ID": 36,
            "Q_TEXT": "Which of the following statements can be used to set the time zone in individual scripts?",
            "Q_PRGM": "",
            "OPT_A": "date_set_timezone(‘Europe/London’);",
            "OPT_B": "date_default_timezone_set(‘Europe/London’);",
            "OPT_C": "date_set_default_timezone(‘Europe/London’);",
            "OPT_D": "date_default_timezone(‘Europe/London’);",
            "ANSWER": 2
          },
          {
            "Q_ID": 37,
            "Q_TEXT": "When you use the $_GET variable to collect data, the data is visible to",
            "Q_PRGM": "",
            "OPT_A": "none",
            "OPT_B": "only you",
            "OPT_C": "everyone",
            "OPT_D": "selected few",
            "ANSWER": 3
          },
          {
            "Q_ID": 38,
            "Q_TEXT": "Which two predefined variables are used to retrieve information from forms?",
            "Q_PRGM": "",
            "OPT_A": "$GET & $SET",
            "OPT_B": "$_GET & $_SET",
            "OPT_C": " $__GET & $__SET",
            "OPT_D": "GET & SET",
            "ANSWER": 2
          },
          {
            "Q_ID": 39,
            "Q_TEXT": "The attack which involves the insertion of malicious code into a page frequented by other users is known as ____",
            "Q_PRGM": "",
            "OPT_A": "basic sql injection",
            "OPT_B": "advanced sql injection",
            "OPT_C": "cross-site scripting",
            "OPT_D": "scripting",
            "ANSWER": 3
          },
          {
            "Q_ID": 40,
            "Q_TEXT": "Before you can start processing images with PHP, you must first add the ability to upload images to your administrative form on ___",
            "Q_PRGM": "",
            "OPT_A": ".htaccess",
            "OPT_B": "function.inc.php",
            "OPT_C": "index.php",
            "OPT_D": "admin.php",
            "ANSWER": 4
          },
          {
            "Q_ID": 41,
            "Q_TEXT": "When you’re uploading files you need to set the enctype of the form to ___",
            "Q_PRGM": "",
            "OPT_A": "text",
            "OPT_B": "text/file",
            "OPT_C": "multipart/form-data",
            "OPT_D": "multimedia/form-data",
            "ANSWER": 3
          },
          {
            "Q_ID": 42,
            "Q_TEXT": "To check whether a file was uploaded, you look in the ___ superglobal array",
            "Q_PRGM": "",
            "OPT_A": "$_FILES",
            "OPT_B": "$_DOCS",
            "OPT_C": "$_DOCUMENTS",
            "OPT_D": "$_FOLDERS",
            "ANSWER": 1
          },
          {
            "Q_ID": 43,
            "Q_TEXT": "Before you try to process the file, you need to make sure that your $err value is equivalent to ___",
            "Q_PRGM": "",
            "OPT_A": "UPLOAD_ERR_OK",
            "OPT_B": "UPLOAD_NO_ERR",
            "OPT_C": "UPLOAD_ERR_NO_OK",
            "OPT_D": "UPLOAD_ERR",
            "ANSWER": 4
          }
        ]
      }
    ]
  }
]
